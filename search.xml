<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「九省2018」秘密袭击]]></title>
    <url>%2F2019%2F03%2F06%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2F%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BB%2F</url>
    <content type="text"><![CDATA[前置技能：树形dp + 卡常大法（雾 苣蒻打了一上午暴力结果只有20pt。。。晕。。。 翻了一下 rqy 的题解，是我不可做的题。。。 再去翻了一下 yyb 的题解，才发现自己是真的🥬。。。 本来背包复杂度是 $O(n^2k^2)$ 的，但是在 $ size $ 的帮助下可以少用一个 $k$，再去掉不可能的情况，最后复杂度是 $ O((n-k)k^2) $. /*Created 2019-3-6*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000 + 5;const int K = 2000 + 5;const int mod = 64123;typedef long long ll;int f[N][K], h[N];int d[N], e[N], sz[N];vector&lt;int&gt; g[N];int n, k, W;void dfs(int u, int fa) &#123; f[u][e[u]] = 1; sz[u] = e[u]; for (int v: g[u]) if (v != fa) &#123; dfs(v, u); for (int i = 0; i &lt;= sz[u] &amp;&amp; i &lt;= k; i++) &#123; for (int j = 0; j &lt;= sz[v] &amp;&amp; i + j &lt;= k; j++) &#123; h[i+j] += (ll)f[u][i] * f[v][j] % mod; &#125; &#125; sz[u] += sz[v]; for (int i = 0; i &lt;= sz[u] &amp;&amp; i &lt;= k; i++) &#123; (f[u][i] += h[i]) %= mod; h[i] = 0; &#125; &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("read.in", "r", stdin); #endif scanf("%d %d %d", &amp;n, &amp;k, &amp;W); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d[i]); &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 1; for (int j = 1; j &lt;= n; j++) &#123; e[j] = d[j] &gt; d[i] || (d[j] == d[i] &amp;&amp; j &lt;= i); cnt += e[j]; &#125; if (cnt &lt; k) &#123; continue; &#125; memset(f, 0, sizeof f); dfs(i, 0); ans = (ans + (ll)f[i][k] * d[i]) % mod; &#125; printf("%d\n", ans); return 0;&#125; 还有一种 $ O(nk) $ 的dp方法，可惜我智商下线，不懂. /*Created 2019-3-6*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000 + 5;const int K = 2000 + 5;const int mod = 64123;typedef long long ll;int f[N][K];int d[N];vector&lt;int&gt; g[N];int n, k, W;void dfs(int x, int u, int fa) &#123; if (d[u] &gt; d[x] || (d[u] == d[x] &amp;&amp; u &lt; x)) &#123; for (int i = 1; i &lt;= k; i++) &#123; f[u][i] = f[fa][i-1]; &#125; &#125; else &#123; for (int i = 1; i &lt;= k; i++) &#123; f[u][i] = f[fa][i]; &#125; &#125; for (int v: g[u]) &#123; if (v != fa) &#123; dfs(x, v, u); &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; (f[fa][i] += f[u][i]) %= mod; &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("read.in", "r", stdin); #endif scanf("%d %d %d", &amp;n, &amp;k, &amp;W); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d[i]); &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 1; for (int j = 1; j &lt;= n; j++) &#123; cnt += d[j] &gt; d[i] || (d[j] == d[i] &amp;&amp; j &lt; i); &#125; if (cnt &lt; k) &#123; continue; &#125; memset(f, 0, sizeof f); f[i][1] = 1; for (int v: g[i]) &#123; dfs(i, v, i); &#125; (ans += (ll)f[i][k] * d[i] % mod) %= mod; &#125; printf("%d\n", ans); return 0;&#125; 在大佬博客下发现了出题人的吐槽： 呵呵。。。]]></content>
      <tags>
        <tag>2018</tag>
        <tag>动态规划</tag>
        <tag>九省联考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「九省2018」IIIDX]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2FIIIDX%2F</url>
    <content type="text"><![CDATA[前置技能：贪心+线段树 记得当年考场上一群人都打了55pt，并且我还自以为是正解写挂，其实还是too young too simple，sometimes naive了. 实际上，正确的思路是考虑在不与前面既定的值发生冲突（即当前取走的点导致前面的点的子树缺少足够的待取值）并且使自身子树有足够的待取值的情况下取尽可能大的值. 当前点取值合法的具体条件是对尚未分配的值（不包括当前点值）存在一种分配方法，使得任意已被取到的值（包括当前点值）都分配有 $ size(子树) ​$ 个大于等于的值. 判断可行性可以用暴力一点的线性做法，这样最后的复杂度有个 $ n^2 ​$，可以拿14个点了.（11点苣蒻路过TAT） 根据经验这种东西肯定可以用简单的数据结构维护（大雾 将频率表减去当前值对应的 $ size ​$ 和，即可通过判断前缀和最小值是否非负决定可行性. 这里的操作涉及到单点修改和维护前缀和最小值，其实不用做区间加减的操作，只需要维护区间和的同时维护最小值即可（别笑我菜我连最简单的操作都不会）. /*Created 2019-3-6*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000 + 5;int n, m;double k, d[N];int sz[N], fa[N];int cnt[N];int ans[N];struct Node &#123; Node *lc, *rc, *fa; int sum, minv; Node (Node *fa = 0) : lc(0x0), rc(0x0), fa(fa), sum(0), minv(0) &#123;&#125;&#125; *root = new Node(), pool[2*N], *pt = pool, *base[N];void update(Node *p) &#123; p-&gt;sum = p-&gt;lc-&gt;sum + p-&gt;rc-&gt;sum; p-&gt;minv = min(p-&gt;lc-&gt;minv + p-&gt;rc-&gt;sum, p-&gt;rc-&gt;minv);&#125;void build(Node *p, int l, int r) &#123; if (l == r) &#123; p-&gt;sum = p-&gt;minv = cnt[l]; base[l] = p; &#125; else &#123; int mid = (l + r) / 2; p-&gt;lc = new (pt++) Node (p); p-&gt;rc = new (pt++) Node (p); build(p-&gt;lc, l, mid); build(p-&gt;rc, mid+1, r); update(p); &#125;&#125;void add(int x, int y) &#123; Node *p = base[x]; p-&gt;sum += y; p-&gt;minv += y; p = p-&gt;fa; while (p) &#123; update(p); p = p-&gt;fa; &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("read.in", "r", stdin); #endif scanf("%d %lf", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf", &amp;d[i]); &#125; for (int i = n; i &gt;= 1; i--) &#123; fa[i] = i / k + 1e-5; sz[fa[i]] += ++sz[i]; &#125; sort(d+1, d+1+n); for (int i = 1; i &lt;= n; i++) &#123; m += d[i] != d[i-1]; d[m] = d[i]; cnt[m]++; &#125; build(root, 1, m); ans[0] = 1; add(ans[0], -n); for (int i = 1; i &lt;= n; i++) &#123; add(ans[fa[i]], sz[i]); int l = ans[fa[i]], r = m+1; while (r - l &gt; 1) &#123; int mid = (l + r) / 2; add(mid, -sz[i]); bool ok = root-&gt;minv &gt;= 0; add(mid, sz[i]); ok ? l = mid : r = mid; &#125; ans[i] = l; add(l, -sz[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%.0lf ", d[ans[i]]); &#125; puts(""); return 0;&#125; 后记：这题磕磕盼盼总算是搞定了，说白了还是在看有没有发现 d 值不同造成贪心的错误. 其他的操作都是顺水推舟的，然而本苣蒻觉得心好累 😣. 另外 rqy 的题解帮我理清了思路，给了提示，还让我又学会了线段树. 膜大神.]]></content>
      <tags>
        <tag>2018</tag>
        <tag>线段树</tag>
        <tag>九省联考</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「九省2018」一双木棋]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2F%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[前置技能：状态压缩动态规划、博弈论基础 先膜一番ouuan大佬，考场切了这题. orz 去年虽然学过状压dp，但是没有观察数据规模加上对博弈不太熟悉，就只拿了10pt送分点. 事实上当前每个状态都可以用其轮廓表示出来，这里设向右为0，向上为1. 对牛牛取反，目标是最小化菲菲的得分. 因为游戏是从左上到右下进行，选择从右下到左上dp. /*Created 2019-3-5*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20;const int inf = 1e9;int m, n;int a[N][N][2], val[N][N][2];int f[1&lt;&lt;N];bool check(int st, int p) &#123; return (st &gt;&gt; p) &amp; 1;&#125;int reverse(int st, int p, int q) &#123; st ^= (1 &lt;&lt; p); st ^= (1 &lt;&lt; q); return st;&#125;int dp(int st, bool turn) &#123; if (f[st] != -1) &#123; return f[st]; &#125; f[st] = turn ? -inf : inf; for (int i = 0, j = check(st, 0); i &lt; m + n - 1; i++, j += check(st, i)) &#123; if (!check(st, i) &amp;&amp; check(st, i+1)) &#123; int upd = a[j+1][m-i+j][turn] + dp(reverse(st, i, i + 1), turn ^ 1); if (turn) &#123; f[st] = max(f[st], upd); &#125; else &#123; f[st] = min(f[st], upd); &#125; &#125; &#125; return f[st];&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("read.in", "r", stdin); #endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j][1]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j][0]); a[i][j][0] = -a[i][j][0]; &#125; &#125; int final = 0, start = 0; for (int i = 0; i &lt; n; i++) &#123; final |= (1 &lt;&lt; i); start |= (1 &lt;&lt; (n+m-i-1)); &#125; memset(f, -1, sizeof f); f[final] = 0; printf("%d\n", dp(start, 1)); return 0;&#125;]]></content>
      <tags>
        <tag>2018</tag>
        <tag>动态规划</tag>
        <tag>九省联考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI Life(3)]]></title>
    <url>%2F2019%2F03%2F04%2FOI%20Life%2FOI-Life-3%2F</url>
    <content type="text"><![CDATA[《OI Life (3)》 星期一： 早上wjyyy大佬突然在群里找人加友链，于是成功互粉. 星期三： 上一场 edu 相当有戏剧效果. 开场一个小时学弟跑来找我，他当时只 A 了两题，我再一看 wjyyy 和 dew 和 ustze，也是两题三题，怕是遇到毒瘤出题人了. 而此时 F 题已经过了 100+ 人了，我就和学弟一起看 F. 一看好像是之前比赛的一道，但是考虑到 CF 出题人不太可能出原题，可能要另辟蹊径. 我又想起来之前在 lrj 的书上看过一个类似的问题，翻了翻那本已经黄了的书，发现并不是那样. 又上百度搜了搜，也没找到什么相关题目. 但是这个问题实在是太经典了所以肯定有什么固定的解法，而且规模是 $ n^3 ​$ 的所以怎么搞都可以. 然后发挥了一下脑洞 yy 了一个状态数 $26*n^2​$ 的dp，然而时间不多了况且晚上比较累，就没实现（只搞了一个贪心 wa #5）. 学弟突然说是bzoj原题，给了个链接，感觉并不是很显然，弃疗. 然后眨眼 dew 就过了 F，接着 wjyyy 也过了，ustze 仍然在刚，我弃疗了，学弟找了份代码改改交过了. 到结束的时候 wjyyy 又卡时过了 D，太巨了，排名在 110+，rating 预计涨 160+. 看了下 dew 的代码，原来是一个 $ n^3 ​$ dp，没想到啊，坑爹，真tm坑爹. 之后发生了很神奇的事，wjyyy 的 A fst 了，过了一会儿 D 也 fst 了，我再一看预估掉 30+ 分，这酸爽，不敢相信. 老司机彻底翻车了. 之前和学弟开黑的一次也 fst x2，不过奇怪的是没怎么掉分.（可能是起始分低） 星期五： 晚上没吃饭打cf，被B题坑惨了，最后敲了100行大模拟硬是过了，坑啊. 然后找学弟要来 C 和 D 幸免了掉分惨案 qwq 打完比赛被学弟拉去吃了顿好的，然而为什么一份 26 块钱的饭只给我放一点点肉？怕我吃胖了吗？嗯？ 回来的路上还和学弟做了一个py交易2333 这场比赛最后还涨了4分，挺感人的. 星期六： 总算翻完了去年HA省的题，怎么都是计数啊我去，太厉害了，而且有两题出的真的烂，一个是细节相当多，一个是硬生生在一个题塞两种idea，可厉害了. 引用vfk在uoj博客上的话： 一道好题应该被仔细推敲过。好题应该有很强的数据，好题应该又清晰的题面，好题的标程应该优美题解应该详尽。 一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。 一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。 一道好题应该具有它的选拔性质，具有足够的区分度。应该至少4档部分分，让新手可以拿到分，让高手能够展示自己的实力。 我想这四点就可以作为平时训练的标准吧.]]></content>
      <tags>
        <tag>OI Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「九省2018」制胡窜（待补）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2F%E5%88%B6%E8%83%A1%E7%AA%9C%2F</url>
    <content type="text"><![CDATA[前置技能：SAM+线段树合并 这题想了好久，原来是我不会线段树合并，SAM也不熟悉，式子还搞错了.😭 我们需要反过来求切割所有匹配的下标对. 放一个我画的草稿： 首先确定最长不相交线段长度，如果大于2则无解，否则求出首尾线段距离最远的相交线段，设为 $ L, R ​$. 之后列出上面的式子计数，发现需要维护一个 $ right ​$ 集合的平方和、一个相邻积和. 平方好算一点，相邻积在合并的时候需要考虑左右两个子集的相邻数字，需要再维护一个 $ size ​$. 最后发现并没有什么特别的地方，就是个大数据结构题，但是我太菜了所以代码写不出来，就挂着先. 复杂度因为二分需要带两个 $ log $，加上常数 26，加上我自带大常数，写出来估计也会跪.😂 吐槽：这题暴力 $ O(qn) ​$ 好像有25pt，简直良心.]]></content>
      <tags>
        <tag>2018</tag>
        <tag>后缀自动机</tag>
        <tag>线段树</tag>
        <tag>九省联考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI Life(2)]]></title>
    <url>%2F2019%2F03%2F01%2FOI%20Life%2FOI-Life-2%2F</url>
    <content type="text"><![CDATA[《OI Life (2)》 星期五： 欸为什么前面几天没有呢？ 不知道啊可能是某人一直在颓忘了写博客了吧？ 星期六： 这个星期没啥事儿啊，就是做做题然后颓一颓而已. 发现 edt 又搞上 slay 了？改了名就以为我不认识你了吗？👻 然后玩了会儿 slay，老年人表示还行，没有被虐的太惨😎]]></content>
      <tags>
        <tag>OI Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「九省2018」劈配]]></title>
    <url>%2F2019%2F03%2F01%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2F%E5%8A%88%E9%85%8D%2F</url>
    <content type="text"><![CDATA[前置技能：最大匹配 + 二分 第一问要求最优匹配使得每个选手的志愿字典序尽量小，那么很容易想到贪心做法，对于每个选手依次连接从高到低的志愿边，每连完一组志愿边就判断匹配是否可以加一，贪心取最小的志愿就行. 证明也很简单. 第二问也是按照第一问的思路，二分位置后，对于前面的点连接所有第一问求出来的志愿边，当前点连接所有 $ s_i $ 及以上的志愿边，判断是否匹配即可. /*Created 2019-3-1*/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200 + 5;const int INF = 0x3f3f3f3f;int S, T;struct Edge &#123; Edge *next, *rev; int v, c; Edge () &#123;&#125; Edge (Edge *next, int v, int c) : next(next), v(v), c(c) &#123;&#125;&#125; *head[2*N], *cur[2*N], pool[2*N*N], *pt = pool;void add_edge(int u, int v, int c) &#123; head[u] = new (pt++) Edge (head[u], v, c); head[v] = new (pt++) Edge (head[v], u, 0); head[u]-&gt;rev = head[v]; head[v]-&gt;rev = head[u];&#125;int lvl[2*N];bool bfs() &#123; memset(lvl, -1, sizeof lvl); lvl[S] = 0; queue&lt;int&gt; q; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (Edge *e = head[u]; e; e = e-&gt;next) &#123; if (e-&gt;c &amp;&amp; lvl[e-&gt;v] == -1) &#123; lvl[e-&gt;v] = lvl[u] + 1; q.push(e-&gt;v); &#125; &#125; &#125; return lvl[T] != -1;&#125;int dfs(int u, int f) &#123; if (u == T || f == 0) &#123; return f; &#125; int vf = 0; for (Edge *e = cur[u]; e; e = e-&gt;next, cur[u] = e) &#123; if (e-&gt;c &amp;&amp; lvl[e-&gt;v] == lvl[u] + 1) &#123; int fl = dfs(e-&gt;v, min(e-&gt;c, f)); vf += fl; f -= fl; e-&gt;c -= fl; e-&gt;rev-&gt;c += fl; if (f == 0) &#123; break; &#125; &#125; &#125; if (!vf) &#123; lvl[u] = -1; &#125; return vf;&#125;int n, m;int dinic() &#123; int mxf = 0; while (bfs()) &#123; for (int i = S; i &lt;= T; i++) &#123; cur[i] = head[i]; &#125; while (int f = dfs(S, INF)) &#123; mxf += f; &#125; &#125; return mxf;&#125;int b[N], s[N];vector&lt;int&gt; idl[N][N];int ans1[N], sum[N];int main() &#123;#ifndef ONLINE_JUDGE freopen("read.in", "r", stdin); freopen("write.out", "w", stdout);#endif int Test, C; scanf("%d %d", &amp;Test, &amp;C); while (Test--) &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; idl[i][j].clear(); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;b[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int id; scanf("%d", &amp;id); idl[i][id].push_back(j); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;s[i]); &#125; S = 0, T = n + m + 1; memset(head, 0, sizeof head); pt = pool; for (int i = 1; i &lt;= n; i++) &#123; add_edge(S, i, 1); &#125; for (int i = 1; i &lt;= m; i++) &#123; add_edge(i + n, T, b[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; ans1[i] = m + 1; for (int j = 1; j &lt;= m; j++) &#123; for (int k: idl[i][j]) &#123; add_edge(i, k + n, 1); &#125; if (dinic() == 1) &#123; ans1[i] = j; break; &#125; &#125; printf("%d ", ans1[i]); &#125; puts(""); for (int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i-1] + (ans1[i] &lt;= m); &#125; for (int i = 1; i &lt;= n; i++) &#123; int l = -1, r = i; while (r - l &gt; 1) &#123; int mid = (l + r) / 2; memset(head, 0, sizeof head); pt = pool; for (int j = 1; j &lt;= n; j++) &#123; add_edge(S, j, 1); &#125; for (int j = 1; j &lt;= m; j++) &#123; add_edge(j + n, T, b[j]); &#125; for (int j = 1; j &lt; i - mid; j++) &#123; for (int k: idl[j][ans1[j]]) &#123; add_edge(j, k + n, 1); &#125; &#125; int mf = dinic(); for (int j = 1; j &lt;= s[i]; j++) &#123; for (int k: idl[i][j]) &#123; add_edge(i, k + n, 1); &#125; &#125; if (dinic() == 1) &#123; r = mid; &#125; else &#123; l = mid; &#125; &#125; printf("%d ", r); &#125; puts(""); &#125; return 0;&#125; 吐槽：因为没清空内存调了半天；去年考试不会网络流，于是最后捡了 5 分，成功避免爆零惨剧.]]></content>
      <tags>
        <tag>2018</tag>
        <tag>九省联考</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「九省2018」林克卡特树]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%9C%81%E9%80%89%2F2018%2F%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83%2F%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前置技能：wqs二分 首先吐槽一下，UOJ群的题解和当时教练发给我们的题解都出了问题，最关键的一面蜜汁不完整. 正解用到了wqs二分，一种降低DP状态维度的方法. 这里引用wqs在论文里的描述： ……对于某个 C，如果最优的划分方案恰好分为 K 段，那么此答案减去 C*K 即为原问题的答案。那么我们只需求出一个恰好分为 K 段的 C 即可。显然，C 值越大，最优解中划分的段数越小，所以我们只需二分 C，获得一个恰好分为 K 段的 C 即可。时间复杂度为 O(nlogC)，其中 C 为某一常数。 ……不过这里还有这样一个问题，可能不存在恰好分为 K 段的 C 值。这可以通过一点修补解决，如果发现 C 取 x 时，所有最优解中最小的分段数大于 K，而取 x+1 时最小的分段数小于 K，那么 C 取 x+1时也存在分段数为 K 的最优解，只需取此时的最优答案减(x+1)*K。 简单来说，就是给每一个划分附加上一个cost，二分cost并计算此时最优解的最小划分数，当划分数为k时，该解对应原最优解. 原本作为状态一维的 k 被拿出来作为计算结果，复杂度大幅降低. /*Created 2019-2-28*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;const int N = 300000 + 5;const int64 INF = 0x3f3f3f3f3f3f3f3f;int n, k;struct Edge &#123; Edge *next; int v, w; Edge() &#123;&#125; Edge(Edge *next, int v, int w) : next(next), v(v), w(w) &#123;&#125;&#125; *head[N], pool[2*N], *pt = pool;void add_edge(int u, int v, int w) &#123; head[u] = new (pt++) Edge (head[u], v, w); head[v] = new (pt++) Edge (head[v], u, w);&#125;struct State &#123; int64 f; int g; State(int64 f = 0, int g = 0) : f(f), g(g) &#123;&#125; bool operator &lt; (const State &amp;s) const &#123; return f &lt; s.f || (f == s.f &amp;&amp; g &lt; s.g); &#125; State operator + (const State &amp;s) const &#123; return State(f + s.f, g + s.g); &#125;&#125; dp[N][3];int64 cost;State aug(State st, int v, int c) &#123; st.f += v; st.f -= cost * c; st.g -= c; return st;&#125;State max(State s, State t) &#123; return s &lt; t ? t : s;&#125;void update(State &amp;s, State t) &#123; s = max(s, t);&#125;void dfs(int u, int f) &#123; dp[u][0] = State(0, 0); dp[u][1] = State(-cost, -1); dp[u][2] = State(-INF, 0); State dp2[3]; for (Edge *e = head[u]; e; e = e-&gt;next) &#123; if (e-&gt;v != f) &#123; dfs(e-&gt;v, u); for (int i = 0; i &lt; 3; i++) &#123; dp2[i] = dp[u][i]; dp[u][i] = State(-INF, 0); &#125; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (dp[e-&gt;v][j].f != -INF) &#123; update(dp[u][i], dp[e-&gt;v][j] + dp2[i]); &#125; &#125; &#125; if (dp[e-&gt;v][1].f != -INF) &#123; update(dp[u][1], dp2[0] + aug(dp[e-&gt;v][1], e-&gt;w, 0)); &#125; if (dp[e-&gt;v][0].f != -INF) &#123; update(dp[u][1], dp2[0] + aug(dp[e-&gt;v][0], e-&gt;w, 1)); &#125; if (dp[e-&gt;v][1].f != -INF) &#123; update(dp[u][2], dp2[1] + aug(dp[e-&gt;v][1], e-&gt;w, -1)); &#125; if (dp[e-&gt;v][0].f != -INF) &#123; update(dp[u][2], dp2[1] + aug(dp[e-&gt;v][0], e-&gt;w, 0)); &#125; &#125; &#125;&#125;State solve() &#123; dfs(1, 0); State ans = State(-INF, 0); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ans = max(ans, dp[i][j]); &#125; &#125; return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("read.in", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;k); k++; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add_edge(u, v, w); &#125; int l = -1e8, r = 1e8; while (r - l &gt; 1) &#123; cost = (l + r) / 2; State ret = solve(); if (-ret.g &gt; k) &#123; l = cost; &#125; else &#123; r = cost; &#125; &#125; int64 ans = -INF; for (int64 i = l; i &lt;= r; i++) &#123; cost = i; State s = solve(); if (-s.g &lt;= k) &#123; ans = max(ans, s.f + i * k); &#125; &#125; printf("%lld\n", ans); return 0;&#125; 参考资料: 《浅析一类二分方法》、Cydiater’s blog]]></content>
      <tags>
        <tag>2018</tag>
        <tag>九省联考</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI Life(1)]]></title>
    <url>%2F2019%2F02%2F24%2FOI%20Life%2FOI%20Life(1)%2F</url>
    <content type="text"><![CDATA[《OI Life (1)》 星期天：下午终于厚着脸皮求edt加友链了. 引导流量++. 😂 为了订阅其他OIer的博客，开始用Feedly，因为眼瞎没找到他们的RSS链接，其实博客上都挂着. 在我苦苦请求下要到了学弟博客的rss，之前他没有开放这个. 星期二：凌晨的CF打出了历史最低分…一直卡在C题上了… 因为平时训练很少接触这种纯细节题，想起来思路就不是很顺畅. 所以平时白天要坚持打vp，才能维持水准. 每天晚饭后可以尝试打一场，因为那时候也会比较犯困，心理状态比起其他时刻更接近凌晨比赛的情况. 而且更槽糕的是，白天一直在调试一道费用流的题，搞得心里非常堵，一直到晚上打比赛心里还是堵. 真是一环套一环. 😥 成功垫底. 另一边传来喜讯：BZOJ过200T啦！ 第200T是 2127: happiness，一道简单的网络流题目. 省选前有望做到300T. 晚上打了一场随机vp，竟然是14年杜教出的题，orzorzorz. 而且那时候zzq还是pupil😂 打的是Div. 2场，然后D写成💩了……. 说给你n个不同的自然数，要求分成两个集合，满足x和a-x同时在A集合，或者x和b-x同时在B集合. 感觉像2-SAT，然而早就忘了2-SAT是啥了😂 然后开始建图，发现不就是贪心配对嘛. 然后就写成💩了…… 看了看题解，就是个并查集，因为x和a-x和b-x要在一起……emm…… 星期三：本来说好要早起来报道的，结果下雨了emm…… 于是事态变得有些失控？为嘛我一大早就坐在机房了？我不应该还躺在床上睡觉觉嘛？😴 星期四：难得跑进最短时间了233 费用流每次增广有单调性，所以直接修改一下模板就行了，不用再二分. 晚上打的是#347，竟然发现了Sengxian大佬😃 中途要交B的时候学校突然断网了😑 等了二十几分钟才恢复. D题是这样的，定义 [n] = {1,…,n}，给出一个 [n]-&gt;[n] 的函数 f，求出两个函数 g([n]-&gt;[m])，h([m]-&gt;[n])，使 g(h(x)) = x (x = [m])，h(g(x)) = f(x) (x = [n]). 其实就是道初中函数题，然而我这个大彩笔直到vp结束都没A 😭 从这两个式子可以推出 g(f(x)) = g(h(g(x))) = g(x)，说明 g(x) = g(f(x)) = g(f(f(x))) = …… 按照这个条件，就可以把 [n] 分为 m 个部分，每个部分对应的 g 值必定是相等的，f 值也是. 进一步发现一定存在 f(x) = x 的情况. 做完所有判定以后，给 f(x) = x 的 g(x) 赋上 [m]，h 值也能用右式推出来. 检查一下发现 g， h 完美地附和条件. (然而彩笔最后没有用 g 推 h 而是搞了个非常神奇的操作并且交错了代码导致 5 WA 😂) 星期五：打了#306 (Div. 2)，构造场. D题说给出整数 k，构造图 G 满足每个点的度数为 k 且存在割边. 猜结论 k 必须是奇数再瞎搞一发 A 了. E 题给一张真值表，0-&gt;0=1，0-&gt;1=1，1-&gt;0=0，1-&gt;1=1，给出一个 01 数组 a，构造运算顺序得到 0. 可以推断 a[n] 必须为0，接下来只需要把所有值往右 push 就可以了，比赛的时候心生倦意没有想. 星期六：早上终于安安心心地睡了个懒觉😁 下午cf正式比赛，发挥还算正常，多亏了最近一直在训练. 虽然最后变成群体涨分最高的了，但是因为底数比较低，涨之后的分数还是很低. 恭喜学弟一路平推上紫了. 下一场只要发挥顺利……（算了别立flag了之前立的flag全倒了😂）]]></content>
      <tags>
        <tag>OI Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI Life(0)]]></title>
    <url>%2F2019%2F02%2F16%2FOI%20Life%2FOI%20Life(0)%2F</url>
    <content type="text"><![CDATA[《OI Life》开坑啦！每周六晚更新 正月初三有场 Global Round #1，Div. 1 + Div. 2，因为上次打 Goodbye 2018 + Hello 2019 自闭了，就没参加，打了场 vp，上交大学生出的，挺简单，很放松. 赛后发现我关注的人都涨了好多分，edt再次上紫了（sro Edgration. orz），学弟上了100+pt，马上要比我高了（qwq），ouuan不出所料涨了30pt（他几乎没掉过分，tql，膜爆）. 如果我打的话也许还能上紫吧，不知道呢. 还是要加油呀，至少跟上大家的步伐吧. 正月初六的 Div. 2 场打到自闭. 题目都不难，但是无端挂了一道，卡了一道，没时间放了一道，最后只完成了3题. 哎，论手速和心态的重要性. 临场发挥的作用甚比于个人水平. 事后又发现自己不会写线段树区间乘法？印象中明明写过的呀，都忘了吗？于是鸽了F. 这天突然记起之前在cf上看到过一个vp hunter，就是那种可以给一组未参加过的比赛列表的小工具. 上谷哥搜了搜，就发现了这么一个东西： Discord上有一个非常神奇的cf讨论组CP Community，组内有个非常神奇的bot，这bot简直就是个神器. 有多神奇呢？你可以让这个bot提供一组可参加的vp比赛. . . 还可以让他和你尬聊 这个神奇的玩意儿是在cf某人的blog里发现的，可以说是业界良心了. 我马上就让他给我整了一组： 简直良心有木有！ 妈妈再也不用担心我找不到vp场啦！ 欸话说vp不就是在contest列表上翻一翻的事儿吗 然而尬聊功能好像下线了. . . 总之以后可以用这个bot找vp打啦！ 总觉得你是在拿一个很trival的东西在水博客 当然，掌握科学上网的姿势是必要的！ 肉身翻墙的请忽略233]]></content>
      <tags>
        <tag>OI Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF WC2019 酱油记]]></title>
    <url>%2F2019%2F01%2F30%2FCCF-WC2019-%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0早上六点四十五起床去赶火车，坐了一上午+一中午的高铁终于到广州南站了，而且因为没准备车上的午餐饿的两眼发绿，一下车就吃了个肯德基。 然后在大巴上颠簸了一个小时到了广州二中。路上还吃了把鸡。来宿舍后和其他湖北OIer面基，发现大家长得都很帅都很成熟，除了xqy还是个孩子的模样。其他人都是第一次见面，还记不住长相，同寝室有一个华一的，也记不住长相。晚上在学校食堂吃，这里的炸鱼块真好吃，看来这一个星期的伙食是不用担心了。八点半去报告厅看开幕式讲座，今年WC要考题答了，然而我还没见过题答，怕是要gg了（就算是传统题也会gg）。有趣的是开幕式有一个节目是阿卡贝拉合唱，然后当即有人发现了玄机：阿卡贝拉——AK不了！怕是真凉凉了（反正我是要爆零的QAQ）。 Day 1今天是听课日，早上记错了时间去完了十分钟。坐在最后面听🌲🌲🌲讲评测系统，然后看他极力推荐评测鸭，发现这真是个厉害的东西，如果CCF也能用这样的评测系统就好了。中间还给听课的人发了一个小黄鸭（当然数量有限我又坐在最后面所以什么也没有），说是可以debug的时候用，还可以带入考场放松心情（其实我们机房也有一个学长留下来的魔方啦，一样的）。中午排了好长的队吃饭，不过等的时间并不长，被强行安排了好多基围虾，额。中午占好下午的座位后在学校里逛了会儿（实际上是找不到回寝室的路了233），在宿舍玩了玩边缘世界，并没有什么很大的进展。下午去听姚班大佬讲量子计算，因为自己实在是太菜加上教师太闷导致精神昏昏沉沉的，不小心趴了一会儿一睁眼就不知道在讲什么了，还好很快就到了课件休息的时候，和学弟跑回寝室了。晚上去体育馆试机，键盘手感好评，不过显示器一会儿就罢工了，不得不换了一台。用手机翻了翻ouuan的博客，看了他写的UER#3T1题解，%得五体投地。 Day 2早上听了具体数学选讲和什么字符串算法，因为内容过（wo）于（tai）硬（cai）核（le）所以打了一上午瞌睡，而且还有点感冒。。。下午听IOI+ACM试题选讲，毫无悬念的又打了一下午瞌睡。。。晚上去听队爷讲课，发现除了LCA大爷讲了自己发明的黑科技，另外的都是搬运了很神奇的论文来讲，毫无悬念我一个都没懂。晚上的CF咕了，怕第二天上午听课吃到，虽然去了也是懵逼的。 Day 3继续懵逼。。。晚上近距离接触了松爷，学弟还和松爷说话了orzorzorz Day 4继续懵逼。。。 Day 5继续懵逼。。。 Day 6考试day，早就做好爆零的准备了qwq（还有yyf继续吊打湖北的准备qwq） 考试前有小姐姐发面包和水好评（虽然面包没吃扔了） 因为事先被告知有三种不同题型，心里还是有点虚。 开T1，发现有几个点集训队分值为1，那么就把这几个点打了吧。打完已经过了两个小时了。代码写了3.8k，全是暴力，太惨了。 T2题面太长了，不想看，就爆零了qwq T3很难搞啊，可能是我没看出有 $\le$ 和 $\ge$ 吧，一直纠结于相等的怎样处理，好在中途继承搞T1的战略把分值最小的点搞了，然后开始自闭，看了看交互库，发现相等会返回rand，然后花15min搞了个rand，虽然知道这样骗不到分，但是总不能闲着啊。最后15min想了想最小的数据点，好像有点搞头，然后考试结束辽。 考完后大家都很懵逼的样子（除我皆fAKe），中午打了几盘斗地主，一手好牌打得稀烂，去看成绩，发现高二我最低？哭辽qwq好像除我皆有牌的样子qwq果不其然yyf又吊打我们了qwq好像ag稳了的样子？去听了听题解，T1神奇的树计数+多项式？还以为prufer序列是不会考的，结果今年考出来了，多项式只会加减乘，呵呵。T2是什么毒瘤乱 搞法？没看题很懵逼。T3大力分析一波，各种大于等于，然后得到很神奇的做法？菜鸡表示只会手玩什么都不会qwq貌似打铁了qwq 晚上临时组织汇演，效率非常高，而且节目效果非常棒，我们都在不停的鼓掌或是大笑。不过后来出了车祸，因为组织者没有审查节目，导致有两个非常不合适的节目上台了，观众都挺尴尬的，最后还演化成动手事故了，收尾不太好，大家都很尴尬。 Day 7早上被强行叫醒乘车去科技馆，路上晕车好难受。太阳好大好大，我还穿着羽绒服qwq等了半天终于进馆了，和学弟绕着馆玩，体验了一把翻车，人生第一次头朝下，感觉很好。因为早上没吃饭，中午饿的要死了，但就是不开饭。最后分到了一份盒饭，一点青菜加瘦肉，不过味道还行。吃完饭等了一个多小时刷知乎刷到自闭终于可以回去了，不知道为什么还要安排饭后有一个小时游览时间，本来一个小时的吃饭时间已经很多了，真的很无聊，差评。回寝室睡了会儿去看闭幕式，为什么要把灯打到观众席啊？本来想看看小姐姐跳舞的结果只能低头刷知乎了qwq中间穿插各种领导讲话，dzd也来了，开始讲话时挺有趣的，破冰效果很好，然后讲了讲传闻的OI成野鸡竞赛面临取缔的问题，告诉我们继续搞，CCF会去处理，算是对家长们的一个交代吧，毕竟从今天上午开始家长群就炸了（反正我很菜的我最多只能上hust的qwq）。 吃完饭和edt道了别，他们凌晨两点的火车还是快速的😂他们还打算先去看个电影再去车站，太厉害了。晚上继续颓啊颓，补完了酱游记。 WC唯一的收获就是一个铁牌和🌲🌲🌲的小黄鸭。顺便还搞丢了水壶。 恭喜湖北喜提三枚Ag，去年还有Au的，今年竟然还开倒车了。（因为我拖后腿了） Day 8回到湖北后才发现现在还是冬天😂因为广州一直都很热，丝毫感觉不到冬天的气息。 我还是喜欢湖北的气候，好歹四季分明吧，广州待着不习惯。]]></content>
      <tags>
        <tag>酱油记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018酱油记]]></title>
    <url>%2F2018%2F11%2F11%2FNOIP2018%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一次写酱油记好激动哦～ Day -365一年前的 NOIP2017 我爆零了QWQ 但是人家只会 DFS，能指望个啥嘛～ Day -10今天打 slay.one 的时候偶遇 WGSZ 的 Edgration 大佬，然后切磋了几把技术，加了 QQ 话说 Edgration 在今年九月份来过我的 QQ 空间，可能是因为我们都在 NOI2018 HB 交流群吧 233 （不过我们都是抱着看神仙的态度去的） 发现 WGSZ 的校内赛好 N13 的样子啊～（此处可能涉及人家的秘诀所以划掉） 然后看 Edgration CF 实力上分涨到 Candidate Master 心里好嫉妒羡慕哦～ （呜呜呜如果当初周末多打几场我也可以的 QWQ） 然后又认识发现了 VixBob 大佬 嗯嗯总之都是大佬就对了 233 听说 edt 大佬什么都会哦～可以吊打学长的哦～ Day 0今天去面基试机，终于见识了 edt 大佬和 bob 大佬本尊！ 长得超帅的！ edt 好羞怯哦～打招呼时好腼腆的样子（嗯可能是本人太菜只配得上大佬一个微笑吧 233） 发现省选时和特派员哥哥大谈网络流的就是 bob 大佬诶！瞬间跪了！ 当然除了 WGSZ 的大佬还见到了很多其它学校的大佬诶 还看到 HSY 组团游街吓得蒟蒻立刻让道了 233 好希望大佬们在 NOIP 能吊打我诶（什么心理啊(￣▽￣)） Day 1哇紧张的早饭都没怎么吃就去考场了 其实是怕吃多了胀气 233 就准备了三颗费列罗撑一上午了 按照程序抽签抽到了 5 排 7 号 嗯没错就是那种人去世后的吊唁活动 怕是要凉凉的节奏哦 自己给自己上坟还行 233 但是即使这样也要把场面搞壮烈一点才行啊 QWQ 抱着就义的心态打开了题面。。。 发现第一题不送分诶！ 差点以为自己要爆炸啦！ 然后撑着脑袋想了一会儿，找个入手点，嗯，树状数组就决定是你了！ 大样例过的飞快，走起～ 不虚不虚，看 T2 哇塞啥玩意儿？？？高斯消元？线性空间？ 完了完了我数学菜死了我要爆零了QWQ 然后陷入了无尽的深渊中无法自拔。。。 大概搞了一个半小时终于艹过去了。。。NM 竟然是完全背包！ 不虚不虚！开 T3！ NM 树上贪心 + 二分！嗯大概就是这个思路了！ 然后接下来的 45+ min 撑着脑袋想怎样贪心。。。 期间发现前排 WGSZ 大佬好像已经开始切了。。。不慌不慌。。。我菜。。。慢慢来。。。 然后大佬敲完了我还在想贪心怎么艹。。。 中途还上了一次厕所（不要指望我像大佬们那样上厕所是为了找灵感，我只是突然有生理需求而已 233） 回来后又想了想，开始敲代码！ QWQ 终于可以开始敲代码了。。。当时感觉大佬们都敲完了整个机房就只有我在小声地敲 QWQ 好丢脸啊 于是接下来的时间都在敲代码了。。。 当然代码不是一次敲完的。。。有好多坑要填的。。。 监考老师提前一刻钟报时时我还在敲 QWQ 要爆炸的节奏哦 感觉自己手速已经达到平生最高了 233 火速敲完 debug 过样例发现已经 11:50 了！ 我艹当时差点要心梗了！感觉心脏有点痛了都！NM 真刺激啊！比蹦极什么的刺激多了！ 眼泪都要飙出来了，欣喜之情无法言表。。。 冷静了 5 分钟，然后按照考场须知整理好文件，再三检查 可能真的是gang的太猛了，水都咽不下去了，冷静了好半天 真 TM 刺激！ （因为样例 AK 被同学 % 了好几次 233） 然后头疼了一下午 QWQ 怕是脑血管爆了哦 QWQ 回家睡了一下午才好一点，而且因为被子太厚差点以为自己发烧了 233 Day 2今天紧张度少了很多诶 233 脸皮太厚了 因为 day1 过于简单导致对 day2 的难度更虚了 233 抱着拿到 T1 100 分就滚粗的心态开了题 首先浏览了一番题目，心里有了一点 B 数 T1 尽然花了一个小时。。。题目读了好几遍 233 然后开 T2。。。 不说了都是泪。。。 一道 T2 送退役。。。 NM 什么鬼？我怕不是穿越了。。。这 NM 是省选把。。。 先是花半个小时打状压 + 矩阵快速幂，过不了样例，定神一想发现有鬼。。。 NM 好像不是这么搞的哦。。。凉了凉了。。。 然后一直在纸上画图猜规律，无果。。。 而且因为体力问题到 10:30 差不多就没脑力了 QWQ 吃了个费列罗也没用。。。 QWQ 心态崩了 QWQ 毫无向下思考的办法。。。真•蒟蒻的绝望。。。 到 11:50 左右终于放弃了。。。转头去敲 T3 暴力。。。没敲完。。。也弃了。。。 况且 T3 正解更没有头绪 QWQ 怕不是真的拿到 100 分就退役吧 QWQ 我还想和小伙伴在机房颓 steam 啊。。。 然后像僵尸一样出考场，看到老爸站在门口差点泪崩。。。太丢人了。。。没脸啊。。。 原来停了半年课还是只会打暴力啊 QWQ 果然还是太菜了 出考场大家好像都很沮丧的样子。。。 哎。。。 然后下午去看电影，clt 大佬一边看一边问其他人的情况 edt 大佬好像在 fAKe。。。cxy 大佬 / KS 大佬 暴力稳的很。。。 大概最多就打个暴力 200- 吧。。。500+ 没指望的。。。 嗯不知道 HSY 的大佬们怎么样了。。。他们真的好自闭啊。。。到现在一点消息都没有。。。 也许 HB 全村的希望真的就在 HSY 了 233 明年包揽省队集体出游也不是不可能的 233 反正广州那地方夏天热得要死，还有蟑螂蚊子啥的，谁爱去谁去，哼！ 不过我省一大概稳了，可以花 2w 去打铁了 233 今年 NOIP 区分度真的低啊，没有什么能做的题。。。 （嗯当然是在不知道 HSY 的实力的情况下的，毕竟人家说不定会集体吊打我们这些散兵的） 现在就等初评了。。。能混一天是一天吧 233 Day 2.5晚上十点源代码就发下来了，day1 T3 T掉三个点只有 85 分（不过学长安慰我说 CCF 的新 CPU 跑的飞快 233） day2 代码出锅，解压出来全是乱码（这是在给我攒 rp 吗？） 所以期望得分 300？ 一天 AK 一天爆零。。。不知道怎么形容了。。。 Day 3今天一早机房就开始滚榜了 那些打 while(true) 的是什么心态啊？ 昨天 edt 大佬狂fAKe，今天洛谷测出 359 pt。。。 cxy 大佬测出 415 pt，rk1 稳了！ 徐教练联系特派员申诉去了，希望挽回一条命吧 233 机房 hxy 同志因为多打了一个 ‘w’ 痛失 100 pt，一个符号送退役 233 （握爪握爪） Day 3.1HSY 高一拿到了 300 pt，真的好强啊！ 高二的估计要吊打我们了 233 Day 3.2早上评测结束了，HSY 高二某大佬暴力打到了 480 pt。稳！ 今年 HSY 怕不是要甩第二名 60 pt 哦！ Day 3.3下午评测时有个外校高一大佬 AC 了 Day2T2。。。 %%%%%% Day 4今天早上机房气氛很颓废 QWQ 我们高二集体被外校 + HSY 的高一大佬送退役了 233 看来我校未来的希望就在隔壁 xht 大佬身上了 233 还有更可怕的事。。。 高一 5 个学弟直接被教练强势劝退了。。。 没办法的事。。。 他们肯定拼不过同届的。。。 所以 xht 成为最后的希望了。。。 然后我校 OI 怕是要凉了。。。 想想真是可怜啊。。。 当年我校 OI 也是能在 NOI 上摘金夺银的。。。 现在一个 NOIP 就把大家打败了。。。 哎。。。 Day 4.2下午颓的不要不要的 玩了一会儿泰拉瑞亚，感觉新手很容易玩腻的 然后下载了 dota2，实属没事找事干 目前没有跑过，听说会烧机？不管了，现在是冬天，万一烧了就拿室外冷一冷好了 233 另外感觉 day1T3 的 multiset 常数大？ 好像全天下都在手写平衡树就我用 multiset 了。。。 希望良心 CCF 不要卡我 multiset 啊～ 顺便不要吃掉我的 100 分啊～ 如果 CCF 够良心我以后就给他氪金！ Day 4.3dota2 竟然没有烧机，真是一件好事 233 开局中路贡献一血菜到不行 233 明天去学校继续提高水平吧 233 初评出来之前真的没有心情搞 OI/综合 了 qwq 另外看到 edt 说说上的退役感想，真的不希望那是真的 我还想跟着大佬 CF 上分呢！ 他现在比我高 100 分，我还想追一追的 现在没有人陪我玩了 qwq（如果接下来我不退役的话） （找不到 HSY 和外校大佬的账号诶） 呃。。。可能要拉着隔壁的学弟打了。。。让他吊打我是个好主意 233 Day 10原本定于今天发布初评成绩，但是 CCF 咕咕咕了，要等到明天早上了。。。 下午和学弟们在机房开黑，嘿嘿嘿^_^ 这几天一直很紧张地等成绩，几乎到了茶饭不思的地步了 我真可怜啊qwq Day 13复测结果下来了，88。。。 垃圾出题人连坑我两题哼 Day1T3也坑掉我 5 分，真是。。。无 fu 可说 Day 13.2呵呵。。。所以最终得分 383？ 当初指望着拿 400 整的，嗯嗯，结果谁料到出题人卡常？ 话说学弟怎么就拿到 100 分了呢？洛谷上明明也TLE了，开 O2 就都过了，难道是复测时没有给我开 O2？好气啊 QAQ （也有可能是学弟 rp 好 233） 然后学长评价是： 我是不是太菜了 QAQ 之前学长让我打 CF、TC，还要做原题，预计结果是这样的： 所以我觉得是我没有打 TC 的原因 如果我打了 TC 就会有 400+ 了 QAQ 现在 HB 可以排 13，233 在 ZJ 可以直接退役了 QAQ 去 NOI 怕不是要被 ZJ 一堆大爷吊打哦 QAQ 蒟蒻瑟瑟发抖 QAQ Day 17这几天比较闲散 233 趁着 steam 秋季折扣去买买买了一波 233 然后开始肝群星了嘿嘿嘿 Day 25下午 5 点成绩出来了，383 分。。。 看来今年卡常很吃亏了呢 QWQ 弱省蒟蒻就这样成功续命了呢 233 现在准备去 WC 膜大佬了 233 真的希望能坐上南航的大飞机啊 233 Day INF哈哈，不能做飞机了，怕晚点，只能做高铁咯]]></content>
      <tags>
        <tag>酱油记</tag>
      </tags>
  </entry>
</search>
