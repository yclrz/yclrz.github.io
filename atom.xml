<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lrz&#39;s blog</title>
  
  <subtitle>too young too simple, sometimes naive.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yclrz.github.io/"/>
  <updated>2019-03-07T08:29:50.700Z</updated>
  <id>https://yclrz.github.io/</id>
  
  <author>
    <name>lrz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【九省2018】秘密袭击</title>
    <link href="https://yclrz.github.io/2019/03/06/%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BB/"/>
    <id>https://yclrz.github.io/2019/03/06/秘密袭击/</id>
    <published>2019-03-06T11:38:20.000Z</published>
    <updated>2019-03-07T08:29:50.700Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：树形dp + 卡常大法（雾</p><a id="more"></a><p>苣蒻打了一上午暴力结果只有20pt。。。晕。。。</p><p>翻了一下 <a href="https://rqy.moe/Solutions/bzoj5250/" target="_blank" rel="noopener">rqy</a> 的题解，是我不可做的题。。。</p><p>再去翻了一下 <a href="https://www.cnblogs.com/cjyyb/p/10367187.html" target="_blank" rel="noopener">yyb</a> 的题解，才发现自己是真的🥬。。。</p><p>本来背包复杂度是 $O(n^2k^2)$ 的，但是在 $ size $ 的帮助下可以少用一个 $k$，再去掉不可能的情况，最后复杂度是 $ O((n-k)k^2) $.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-3-6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">64123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][K], h[N];</span><br><span class="line"><span class="keyword">int</span> d[N], e[N], sz[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> n, k, W;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  f[u][e[u]] = <span class="number">1</span>;</span><br><span class="line">  sz[u] = e[u];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz[u] &amp;&amp; i &lt;= k; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz[v] &amp;&amp; i + j &lt;= k; j++) &#123;</span><br><span class="line">        h[i+j] += (ll)f[u][i] * f[v][j] % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz[u] &amp;&amp; i &lt;= k; i++) &#123;</span><br><span class="line">      (f[u][i] += h[i]) %= mod;</span><br><span class="line">      h[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;k, &amp;W);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      e[j] = d[j] &gt; d[i] || (d[j] == d[i] &amp;&amp; j &lt;= i);</span><br><span class="line">      cnt += e[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    dfs(i, <span class="number">0</span>);</span><br><span class="line">    ans = (ans + (ll)f[i][k] * d[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种 $ O(nk) $ 的dp方法，可惜我智商下线，不懂.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-3-6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">64123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][K];</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> n, k, W;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[u] &gt; d[x] || (d[u] == d[x] &amp;&amp; u &lt; x)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      f[u][i] = f[fa][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      f[u][i] = f[fa][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v: g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">      dfs(x, v, u);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    (f[fa][i] += f[u][i]) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;k, &amp;W);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      cnt += d[j] &gt; d[i] || (d[j] == d[i] &amp;&amp; j &lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: g[i]) &#123;</span><br><span class="line">      dfs(i, v, i);</span><br><span class="line">    &#125;</span><br><span class="line">    (ans += (ll)f[i][k] * d[i] % mod) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大佬博客下发现了出题人的吐槽：</p><p><img src="https://s2.ax1x.com/2019/03/07/kxQb8K.png" alt=""></p><p>呵呵。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：树形dp + 卡常大法（雾&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="动态规划" scheme="https://yclrz.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【九省2018】IIIDX</title>
    <link href="https://yclrz.github.io/2019/03/05/IIIDX/"/>
    <id>https://yclrz.github.io/2019/03/05/IIIDX/</id>
    <published>2019-03-05T12:20:00.000Z</published>
    <updated>2019-03-07T07:01:51.783Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：贪心+线段树</p><a id="more"></a><p>记得当年考场上一群人都打了55pt，并且我还自以为是正解写挂，其实还是too young too simple，sometimes naive了.</p><p>实际上，正确的思路是考虑在不与前面既定的值发生冲突（即当前取走的点导致前面的点的子树缺少足够的待取值）并且使自身子树有足够的待取值的情况下取尽可能大的值.</p><p>当前点取值合法的具体条件是对尚未分配的值（不包括当前点值）存在一种分配方法，使得任意已被取到的值（包括当前点值）都分配有 $ size(子树) ​$ 个大于等于的值.</p><p>判断可行性可以用暴力一点的线性做法，这样最后的复杂度有个 $ n^2 ​$，可以拿14个点了.（11点苣蒻路过TAT）</p><p>根据经验这种东西肯定可以用简单的数据结构维护（大雾</p><p>将频率表减去当前值对应的 $ size ​$ 和，即可通过判断前缀和最小值是否非负决定可行性.</p><p>这里的操作涉及到单点修改和维护前缀和最小值，其实不用做区间加减的操作，只需要维护区间和的同时维护最小值即可（别笑我菜我连最简单的操作都不会）.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-3-6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> k, d[N];</span><br><span class="line"><span class="keyword">int</span> sz[N], fa[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node *lc, *rc, *fa;</span><br><span class="line">  <span class="keyword">int</span> sum, minv;</span><br><span class="line">  Node (Node *fa = <span class="number">0</span>) : lc(<span class="number">0x0</span>), rc(<span class="number">0x0</span>), fa(fa), sum(<span class="number">0</span>), minv(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; *root = <span class="keyword">new</span> Node(), pool[<span class="number">2</span>*N], *pt = pool, *base[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Node *p)</span> </span>&#123;</span><br><span class="line">  p-&gt;sum = p-&gt;lc-&gt;sum + p-&gt;rc-&gt;sum;</span><br><span class="line">  p-&gt;minv = min(p-&gt;lc-&gt;minv + p-&gt;rc-&gt;sum, p-&gt;rc-&gt;minv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    p-&gt;sum = p-&gt;minv = cnt[l];</span><br><span class="line">    base[l] = p;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    p-&gt;lc = <span class="keyword">new</span> (pt++) Node (p);</span><br><span class="line">    p-&gt;rc = <span class="keyword">new</span> (pt++) Node (p);</span><br><span class="line">    build(p-&gt;lc, l, mid);</span><br><span class="line">    build(p-&gt;rc, mid+<span class="number">1</span>, r);</span><br><span class="line">    update(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  Node *p = base[x];</span><br><span class="line">  p-&gt;sum += y;</span><br><span class="line">  p-&gt;minv += y;</span><br><span class="line">  p = p-&gt;fa;</span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    update(p);</span><br><span class="line">    p = p-&gt;fa;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;d[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    fa[i] = i / k + <span class="number">1e-5</span>;</span><br><span class="line">    sz[fa[i]] += ++sz[i];</span><br><span class="line">  &#125;</span><br><span class="line">  sort(d+<span class="number">1</span>, d+<span class="number">1</span>+n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    m += d[i] != d[i<span class="number">-1</span>];</span><br><span class="line">    d[m] = d[i];</span><br><span class="line">    cnt[m]++;</span><br><span class="line">  &#125;</span><br><span class="line">  build(root, <span class="number">1</span>, m);</span><br><span class="line">  ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  add(ans[<span class="number">0</span>], -n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(ans[fa[i]], sz[i]);</span><br><span class="line">    <span class="keyword">int</span> l = ans[fa[i]], r = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">      add(mid, -sz[i]);</span><br><span class="line">      <span class="keyword">bool</span> ok = root-&gt;minv &gt;= <span class="number">0</span>;</span><br><span class="line">      add(mid, sz[i]);</span><br><span class="line">      ok ? l = mid : r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = l;</span><br><span class="line">    add(l, -sz[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf "</span>, d[ans[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后记：这题磕磕盼盼总算是搞定了，说白了还是在看有没有发现 d 值不同造成贪心的错误. 其他的操作都是顺水推舟的，然而本苣蒻觉得心好累 😣. 另外 <a href="https://rqy.moe/Solutions/bzoj5249/" target="_blank" rel="noopener">rqy</a> 的题解帮我理清了思路，给了提示，还让我又学会了线段树. 膜大神.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：贪心+线段树&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="贪心" scheme="https://yclrz.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="线段树" scheme="https://yclrz.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【九省2018】一双木棋</title>
    <link href="https://yclrz.github.io/2019/03/05/%E7%9C%81%E9%80%89/2018/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B/"/>
    <id>https://yclrz.github.io/2019/03/05/省选/2018/九省联考/一双木棋/</id>
    <published>2019-03-05T08:28:05.000Z</published>
    <updated>2019-03-07T04:02:38.774Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：状态压缩动态规划、博弈论基础</p><a id="more"></a><p>先膜一番ouuan大佬，考场切了这题. orz</p><p>去年虽然学过状压dp，但是没有观察数据规模加上对博弈不太熟悉，就只拿了10pt送分点.</p><p>事实上当前每个状态都可以用其轮廓表示出来，这里设向右为0，向上为1.</p><p>对牛牛取反，目标是最小化菲菲的得分.</p><p>因为游戏是从左上到右下进行，选择从右下到左上dp.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-3-5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> a[N][N][<span class="number">2</span>], val[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (st &gt;&gt; p) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  st ^= (<span class="number">1</span> &lt;&lt; p);</span><br><span class="line">  st ^= (<span class="number">1</span> &lt;&lt; q);</span><br><span class="line">  <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">bool</span> turn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f[st] != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> f[st];</span><br><span class="line">  &#125;</span><br><span class="line">  f[st] = turn ? -inf : inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = check(st, <span class="number">0</span>); i &lt; m + n - <span class="number">1</span>; i++, j += check(st, i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!check(st, i) &amp;&amp; check(st, i+<span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">int</span> upd = a[j+<span class="number">1</span>][m-i+j][turn] + dp(reverse(st, i, i + <span class="number">1</span>), turn ^ <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (turn) &#123;</span><br><span class="line">        f[st] = max(f[st], upd);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f[st] = min(f[st], upd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[st];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j][<span class="number">0</span>]);</span><br><span class="line">      a[i][j][<span class="number">0</span>] = -a[i][j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> final = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    final |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    start |= (<span class="number">1</span> &lt;&lt; (n+m-i<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[final] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(start, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：状态压缩动态规划、博弈论基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="动态规划" scheme="https://yclrz.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>OI Life(3)</title>
    <link href="https://yclrz.github.io/2019/03/04/OI%20Life/OI-Life-3/"/>
    <id>https://yclrz.github.io/2019/03/04/OI Life/OI-Life-3/</id>
    <published>2019-03-04T02:47:17.000Z</published>
    <updated>2019-03-06T07:46:05.556Z</updated>
    
    <content type="html"><![CDATA[<p>《OI Life (3)》</p><a id="more"></a><p>星期一：</p><p>早上wjyyy大佬突然在群里找人加友链，于是成功互粉.</p><p>星期三：</p><p>上一场 edu 相当有戏剧效果. </p><p>开场一个小时学弟跑来找我，他当时只 A 了两题，我再一看 wjyyy 和 dew 和 ustze，也是两题三题，怕是遇到毒瘤出题人了. </p><p>而此时 F 题已经过了 100+ 人了，我就和学弟一起看 F. </p><p>一看好像是之前比赛的一道，但是考虑到 CF 出题人不太可能出原题，可能要另辟蹊径. </p><p>我又想起来之前在 lrj 的书上看过一个类似的问题，翻了翻那本已经黄了的书，发现并不是那样. </p><p>又上百度搜了搜，也没找到什么相关题目. </p><p>但是这个问题实在是太经典了所以肯定有什么固定的解法，而且规模是 $ n^3 ​$ 的所以怎么搞都可以. </p><p>然后发挥了一下脑洞 yy 了一个状态数 $26*n^2​$ 的dp，然而时间不多了况且晚上比较累，就没实现（只搞了一个贪心 wa #5）. </p><p>学弟突然说是bzoj原题，给了个链接，感觉并不是很显然，弃疗. </p><p>然后眨眼 dew 就过了 F，接着 wjyyy 也过了，ustze 仍然在刚，我弃疗了，学弟找了份代码改改交过了. </p><p>到结束的时候 wjyyy 又卡时过了 D，太巨了，排名在 110+，rating 预计涨 160+. </p><p>看了下 dew 的代码，原来是一个 $ n^3 ​$ dp，没想到啊，坑爹，真tm坑爹.</p><p>之后发生了很神奇的事，wjyyy 的 A fst 了，过了一会儿 D 也 fst 了，我再一看预估掉 30+ 分，这酸爽，不敢相信. 老司机彻底翻车了. </p><p>之前和学弟开黑的一次也 fst x2，不过奇怪的是没怎么掉分.（可能是起始分低）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OI Life (3)》&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI Life" scheme="https://yclrz.github.io/tags/OI-Life/"/>
    
  </entry>
  
  <entry>
    <title>【九省2018】制胡窜（待补）</title>
    <link href="https://yclrz.github.io/2019/03/02/%E7%9C%81%E9%80%89/2018/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/%E5%88%B6%E8%83%A1%E7%AA%9C/"/>
    <id>https://yclrz.github.io/2019/03/02/省选/2018/九省联考/制胡窜/</id>
    <published>2019-03-02T08:28:54.000Z</published>
    <updated>2019-03-07T04:02:50.028Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：SAM+线段树合并</p><a id="more"></a><p>这题想了好久，原来是我不会线段树合并，SAM也不熟悉，式子还搞错了.😭</p><p>我们需要反过来求切割所有匹配的下标对.</p><p>放一个我画的草稿：</p><p><img src="https://s2.ax1x.com/2019/03/05/kX701I.png" alt=""></p><p>首先确定最长不相交线段长度，如果大于2则无解，否则求出首尾线段距离最远的相交线段，设为 $ L, R ​$. 之后列出上面的式子计数，发现需要维护一个 $ right ​$ 集合的平方和、一个相邻积和. 平方好算一点，相邻积在合并的时候需要考虑左右两个子集的相邻数字，需要再维护一个 $ size ​$.</p><p>最后发现并没有什么特别的地方，就是个大数据结构题，但是我太菜了所以代码写不出来，就挂着先.</p><p>复杂度因为二分需要带两个 $ log $，加上常数 26，加上我自带大常数，写出来估计也会跪.😂</p><p>吐槽：这题暴力 $ O(qn) ​$ 好像有25pt，简直良心.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：SAM+线段树合并&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="线段树" scheme="https://yclrz.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="后缀自动机" scheme="https://yclrz.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>OI Life(2)</title>
    <link href="https://yclrz.github.io/2019/03/01/OI%20Life/OI-Life-2/"/>
    <id>https://yclrz.github.io/2019/03/01/OI Life/OI-Life-2/</id>
    <published>2019-03-01T12:48:55.000Z</published>
    <updated>2019-03-03T02:27:58.584Z</updated>
    
    <content type="html"><![CDATA[<p>《OI Life (2)》</p><a id="more"></a><p>星期五：</p><p>欸为什么前面几天没有呢？</p><p>不知道啊可能是某人一直在颓忘了写博客了吧？</p><p>星期六：</p><p>这个星期没啥事儿啊，就是做做题然后颓一颓而已.</p><p>发现 edt 又搞上 slay 了？改了名就以为我不认识你了吗？👻</p><p>然后玩了会儿 slay，老年人表示还行，没有被虐的太惨😎</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OI Life (2)》&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI Life" scheme="https://yclrz.github.io/tags/OI-Life/"/>
    
  </entry>
  
  <entry>
    <title>【九省2018】劈配</title>
    <link href="https://yclrz.github.io/2019/03/01/%E7%9C%81%E9%80%89/2018/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/%E5%8A%88%E9%85%8D/"/>
    <id>https://yclrz.github.io/2019/03/01/省选/2018/九省联考/劈配/</id>
    <published>2019-03-01T10:55:25.000Z</published>
    <updated>2019-03-07T04:02:35.805Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：最大匹配 + 二分</p><a id="more"></a><p>第一问要求最优匹配使得每个选手的志愿字典序尽量小，那么很容易想到贪心做法，对于每个选手依次连接从高到低的志愿边，每连完一组志愿边就判断匹配是否可以加一，贪心取最小的志愿就行. 证明也很简单.</p><p>第二问也是按照第一问的思路，二分位置后，对于前面的点连接所有第一问求出来的志愿边，当前点连接所有 $ s_i $ 及以上的志愿边，判断是否匹配即可.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-3-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  Edge *next, *rev;</span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  Edge () &#123;&#125;</span><br><span class="line">  Edge (Edge *next, <span class="keyword">int</span> v, <span class="keyword">int</span> c) : next(next), v(v), c(c) &#123;&#125;</span><br><span class="line">&#125; *head[<span class="number">2</span>*N], *cur[<span class="number">2</span>*N], pool[<span class="number">2</span>*N*N], *pt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  head[u] = <span class="keyword">new</span> (pt++) Edge (head[u], v, c);</span><br><span class="line">  head[v] = <span class="keyword">new</span> (pt++) Edge (head[v], u, <span class="number">0</span>);</span><br><span class="line">  head[u]-&gt;rev = head[v];</span><br><span class="line">  head[v]-&gt;rev = head[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lvl[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(lvl, <span class="number">-1</span>, <span class="keyword">sizeof</span> lvl);</span><br><span class="line">  lvl[S] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(S);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = head[u]; e; e = e-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e-&gt;c &amp;&amp; lvl[e-&gt;v] == <span class="number">-1</span>) &#123;</span><br><span class="line">        lvl[e-&gt;v] = lvl[u] + <span class="number">1</span>;</span><br><span class="line">        q.push(e-&gt;v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lvl[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == T || f == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> vf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Edge *e = cur[u]; e; e = e-&gt;next, cur[u] = e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;c &amp;&amp; lvl[e-&gt;v] == lvl[u] + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> fl = dfs(e-&gt;v, min(e-&gt;c, f));</span><br><span class="line">      vf += fl;</span><br><span class="line">      f -= fl;</span><br><span class="line">      e-&gt;c -= fl;</span><br><span class="line">      e-&gt;rev-&gt;c += fl;</span><br><span class="line">      <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vf) &#123;</span><br><span class="line">    lvl[u] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mxf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= T; i++) &#123;</span><br><span class="line">      cur[i] = head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">int</span> f = dfs(S, INF)) &#123;</span><br><span class="line">      mxf += f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mxf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[N], s[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idl[N][N];</span><br><span class="line"><span class="keyword">int</span> ans1[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">"write.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Test, C;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Test, &amp;C);</span><br><span class="line">  <span class="keyword">while</span> (Test--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        idl[i][j].clear();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">        idl[i][id].push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    pt = pool;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      add_edge(S, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      add_edge(i + n, T, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      ans1[i] = m + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k: idl[i][j]) &#123;</span><br><span class="line">          add_edge(i, k + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dinic() == <span class="number">1</span>) &#123;</span><br><span class="line">          ans1[i] = j;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      sum[i] = sum[i<span class="number">-1</span>] + (ans1[i] &lt;= m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> l = <span class="number">-1</span>, r = i;</span><br><span class="line">      <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        pt = pool;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          add_edge(S, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">          add_edge(j + n, T, b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i - mid; j++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k: idl[j][ans1[j]]) &#123;</span><br><span class="line">            add_edge(j, k + n, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mf = dinic();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k: idl[i][j]) &#123;</span><br><span class="line">            add_edge(i, k + n, <span class="number">1</span>); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dinic() == <span class="number">1</span>) &#123;</span><br><span class="line">          r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吐槽：因为没清空内存调了半天；去年考试不会网络流，于是最后捡了 5 分，成功避免爆零惨剧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：最大匹配 + 二分&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="网络流" scheme="https://yclrz.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【九省2018】林克卡特树</title>
    <link href="https://yclrz.github.io/2019/02/28/%E7%9C%81%E9%80%89/2018/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91/"/>
    <id>https://yclrz.github.io/2019/02/28/省选/2018/九省联考/林克卡特树/</id>
    <published>2019-02-28T08:30:04.000Z</published>
    <updated>2019-03-07T04:02:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>前置技能：wqs二分</p><a id="more"></a><p>首先吐槽一下，UOJ群的题解和当时教练发给我们的题解都出了问题，最关键的一面蜜汁不完整.</p><p>正解用到了wqs二分，一种降低DP状态维度的方法.</p><p>这里引用wqs在论文里的描述：</p><blockquote><p>……对于某个 C，如果最优的划分方案恰好分为 K 段，那么此答案减去 C*K 即为原问题的答案。那么我们只需求出一个恰好分为 K 段的 C 即可。显然，C 值越大，最优解中划分的段数越小，所以我们只需二分 C，获得一个恰好分为 K 段的 C 即可。时间复杂度为 O(nlogC)，其中 C 为某一常数。</p><p>……不过这里还有这样一个问题，可能不存在恰好分为 K 段的 C 值。这可以通过一点修补解决，如果发现 C 取 x 时，所有最优解中最小的分段数大于 K，而取 x+1 时最小的分段数小于 K，那么 C 取 x+1时也存在分段数为 K 的最优解，只需取此时的最优答案减(x+1)*K。</p></blockquote><p>简单来说，就是给每一个划分附加上一个cost，二分cost并计算此时最优解的最小划分数，当划分数为k时，该解对应原最优解. 原本作为状态一维的 k 被拿出来作为计算结果，复杂度大幅降低.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created 2019-2-28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> int64 INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  Edge *next;</span><br><span class="line">  <span class="keyword">int</span> v, w;</span><br><span class="line">  Edge() &#123;&#125;</span><br><span class="line">  Edge(Edge *next, <span class="keyword">int</span> v, <span class="keyword">int</span> w) : next(next), v(v), w(w) &#123;&#125;</span><br><span class="line">&#125; *head[N], pool[<span class="number">2</span>*N], *pt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  head[u] = <span class="keyword">new</span> (pt++) Edge (head[u], v, w);</span><br><span class="line">  head[v] = <span class="keyword">new</span> (pt++) Edge (head[v], u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">  int64 f;</span><br><span class="line">  <span class="keyword">int</span> g;</span><br><span class="line">  State(int64 f = <span class="number">0</span>, <span class="keyword">int</span> g = <span class="number">0</span>) : f(f), g(g) &#123;&#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> State &amp;s) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f &lt; s.f || (f == s.f &amp;&amp; g &lt; s.g);</span><br><span class="line">  &#125;</span><br><span class="line">  State <span class="keyword">operator</span> + (<span class="keyword">const</span> State &amp;s) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State(f + s.f, g + s.g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; dp[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">int64 cost;</span><br><span class="line"></span><br><span class="line"><span class="function">State <span class="title">aug</span><span class="params">(State st, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  st.f += v;</span><br><span class="line">  st.f -= cost * c;</span><br><span class="line">  st.g -= c;</span><br><span class="line">  <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">State <span class="title">max</span><span class="params">(State s, State t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s &lt; t ? t : s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(State &amp;s, State t)</span> </span>&#123;</span><br><span class="line">  s = max(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">0</span>] = State(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  dp[u][<span class="number">1</span>] = State(-cost, <span class="number">-1</span>);</span><br><span class="line">  dp[u][<span class="number">2</span>] = State(-INF, <span class="number">0</span>);</span><br><span class="line">  State dp2[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (Edge *e = head[u]; e; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;v != f) &#123;</span><br><span class="line">      dfs(e-&gt;v, u);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        dp2[i] = dp[u][i];</span><br><span class="line">        dp[u][i] = State(-INF, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dp[e-&gt;v][j].f != -INF) &#123;</span><br><span class="line">            update(dp[u][i], dp[e-&gt;v][j] + dp2[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[e-&gt;v][<span class="number">1</span>].f != -INF) &#123;</span><br><span class="line">        update(dp[u][<span class="number">1</span>], dp2[<span class="number">0</span>] + aug(dp[e-&gt;v][<span class="number">1</span>], e-&gt;w, <span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[e-&gt;v][<span class="number">0</span>].f != -INF) &#123;</span><br><span class="line">        update(dp[u][<span class="number">1</span>], dp2[<span class="number">0</span>] + aug(dp[e-&gt;v][<span class="number">0</span>], e-&gt;w, <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[e-&gt;v][<span class="number">1</span>].f != -INF) &#123;</span><br><span class="line">        update(dp[u][<span class="number">2</span>], dp2[<span class="number">1</span>] + aug(dp[e-&gt;v][<span class="number">1</span>], e-&gt;w, <span class="number">-1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[e-&gt;v][<span class="number">0</span>].f != -INF) &#123;</span><br><span class="line">        update(dp[u][<span class="number">2</span>], dp2[<span class="number">1</span>] + aug(dp[e-&gt;v][<span class="number">0</span>], e-&gt;w, <span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">State <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  State ans = State(-INF, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      ans = max(ans, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"read.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">  k++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    add_edge(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">-1e8</span>, r = <span class="number">1e8</span>;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    cost = (l + r) / <span class="number">2</span>;</span><br><span class="line">    State ret = solve();</span><br><span class="line">    <span class="keyword">if</span> (-ret.g &gt; k) &#123;</span><br><span class="line">      l = cost;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int64 ans = -INF;</span><br><span class="line">  <span class="keyword">for</span> (int64 i = l; i &lt;= r; i++) &#123;</span><br><span class="line">    cost = i;</span><br><span class="line">    State s = solve();</span><br><span class="line">    <span class="keyword">if</span> (-s.g &lt;= k) &#123;</span><br><span class="line">      ans = max(ans, s.f + i * k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料: <a href="http://www.tsinsen.com/resources/Train2012-sol-wqs.pdf" target="_blank" rel="noopener">《浅析一类二分方法》</a>、<a href="https://cydiater.me/2018/05/21/%E3%80%8CBZOJ5252%E3%80%8D%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91/" target="_blank" rel="noopener">Cydiater’s blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前置技能：wqs二分&lt;/p&gt;
    
    </summary>
    
    
      <category term="九省联考" scheme="https://yclrz.github.io/tags/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83/"/>
    
      <category term="2018" scheme="https://yclrz.github.io/tags/2018/"/>
    
      <category term="二分" scheme="https://yclrz.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>OI Life(1)</title>
    <link href="https://yclrz.github.io/2019/02/24/OI%20Life/OI%20Life(1)/"/>
    <id>https://yclrz.github.io/2019/02/24/OI Life/OI Life(1)/</id>
    <published>2019-02-23T17:14:00.000Z</published>
    <updated>2019-03-03T02:27:45.140Z</updated>
    
    <content type="html"><![CDATA[<p>《OI Life (1)》</p><a id="more"></a><h4 id="星期天："><a href="#星期天：" class="headerlink" title="星期天："></a>星期天：</h4><p>下午终于厚着脸皮求edt加友链了. 引导流量++. 😂</p><p>为了订阅其他OIer的博客，开始用Feedly，因为眼瞎没找到他们的RSS链接，其实博客上都挂着.</p><p>在我苦苦请求下要到了学弟博客的rss，之前他没有开放这个.</p><h4 id="星期二："><a href="#星期二：" class="headerlink" title="星期二："></a>星期二：</h4><p>凌晨的CF打出了历史最低分…一直卡在C题上了…</p><p>因为平时训练很少接触这种纯细节题，想起来思路就不是很顺畅.</p><p>所以平时白天要坚持打vp，才能维持水准.</p><p>每天晚饭后可以尝试打一场，因为那时候也会比较犯困，心理状态比起其他时刻更接近凌晨比赛的情况.</p><p>而且更槽糕的是，白天一直在调试一道费用流的题，搞得心里非常堵，一直到晚上打比赛心里还是堵.</p><p>真是一环套一环. 😥</p><p><img src="https://s2.ax1x.com/2019/02/19/kgu0zt.png" alt=""></p><p>成功垫底.</p><p>另一边传来喜讯：BZOJ过200T啦！</p><p><img src="https://s2.ax1x.com/2019/02/19/kglHj1.png" alt=""></p><p>第200T是 <a href="https://lydsy.com/JudgeOnline/problem.php?id=2127" target="_blank" rel="noopener">2127: happiness</a>，一道简单的网络流题目.</p><p>省选前有望做到300T.</p><p>晚上打了一场随机vp，竟然是14年杜教出的题，orzorzorz.</p><p>而且那时候zzq还是pupil😂</p><p>打的是Div. 2场，然后D写成💩了…….</p><p>说给你n个不同的自然数，要求分成两个集合，满足x和a-x同时在A集合，或者x和b-x同时在B集合.</p><p>感觉像2-SAT，然而早就忘了2-SAT是啥了😂</p><p>然后开始建图，发现不就是贪心配对嘛.</p><p>然后就写成💩了……</p><p>看了看题解，就是个并查集，因为x和a-x和b-x要在一起……emm……</p><h4 id="星期三："><a href="#星期三：" class="headerlink" title="星期三："></a>星期三：</h4><p>本来说好要早起来报道的，结果下雨了emm……</p><p>于是事态变得有些失控？为嘛我一大早就坐在机房了？我不应该还躺在床上睡觉觉嘛？😴</p><h4 id="星期四："><a href="#星期四：" class="headerlink" title="星期四："></a>星期四：</h4><p>难得跑进最短时间了233</p><p><img src="https://s2.ax1x.com/2019/02/21/kRr6JJ.png" alt=""></p><p>费用流每次增广有单调性，所以直接修改一下模板就行了，不用再二分.</p><p>晚上打的是#347，竟然发现了Sengxian大佬😃</p><p>中途要交B的时候学校突然断网了😑 等了二十几分钟才恢复.</p><p>D题是这样的，定义 [n] = {1,…,n}，给出一个 [n]-&gt;[n] 的函数 f，求出两个函数 g([n]-&gt;[m])，h([m]-&gt;[n])，使 g(h(x)) = x (x = [m])，h(g(x)) = f(x) (x = [n]).</p><p>其实就是道初中函数题，然而我这个大彩笔直到vp结束都没A 😭</p><p>从这两个式子可以推出 g(f(x)) = g(h(g(x))) = g(x)，说明 g(x) = g(f(x)) = g(f(f(x))) = ……</p><p>按照这个条件，就可以把 [n] 分为 m 个部分，每个部分对应的 g 值必定是相等的，f 值也是.</p><p>进一步发现一定存在 f(x) = x 的情况.</p><p>做完所有判定以后，给 f(x) = x 的 g(x) 赋上 [m]，h 值也能用右式推出来.</p><p>检查一下发现 g， h 完美地附和条件.</p><p>(然而彩笔最后没有用 g 推 h 而是搞了个非常神奇的操作并且交错了代码导致 5 WA 😂)</p><h4 id="星期五："><a href="#星期五：" class="headerlink" title="星期五："></a>星期五：</h4><p>打了#306 (Div. 2)，构造场.</p><p>D题说给出整数 k，构造图 G 满足每个点的度数为 k 且存在割边. 猜结论 k 必须是奇数再瞎搞一发 A 了.</p><p>E 题给一张真值表，0-&gt;0=1，0-&gt;1=1，1-&gt;0=0，1-&gt;1=1，给出一个 01 数组 a，构造运算顺序得到 0. 可以推断 a[n] 必须为0，接下来只需要把所有值往右 push 就可以了，比赛的时候心生倦意没有想.</p><h4 id="星期六："><a href="#星期六：" class="headerlink" title="星期六："></a>星期六：</h4><p>早上终于安安心心地睡了个懒觉😁</p><p>下午cf正式比赛，发挥还算正常，多亏了最近一直在训练.</p><p>虽然最后变成群体涨分最高的了，但是因为底数比较低，涨之后的分数还是很低.</p><p>恭喜学弟一路平推上紫了.</p><p><img src="https://s2.ax1x.com/2019/02/24/k4kf1I.png" alt=""></p><p>下一场只要发挥顺利……（算了别立flag了之前立的flag全倒了😂）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OI Life (1)》&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI Life" scheme="https://yclrz.github.io/tags/OI-Life/"/>
    
  </entry>
  
  <entry>
    <title>OI Life(0)</title>
    <link href="https://yclrz.github.io/2019/02/16/OI%20Life/OI%20Life(0)/"/>
    <id>https://yclrz.github.io/2019/02/16/OI Life/OI Life(0)/</id>
    <published>2019-02-16T07:37:23.000Z</published>
    <updated>2019-03-02T10:58:29.505Z</updated>
    
    <content type="html"><![CDATA[<p>《OI Life》开坑啦！每周六晚更新</p><a id="more"></a><p>正月初三有场 Global Round #1，Div. 1 + Div. 2，因为上次打 Goodbye 2018 + Hello 2019 自闭了，就没参加，打了场 vp，上交大学生出的，挺简单，很放松. 赛后发现我关注的人都涨了好多分，edt再次上紫了（sro Edgration.  orz），学弟上了100+pt，马上要比我高了（qwq），ouuan不出所料涨了30pt（他几乎没掉过分，tql，膜爆）. 如果我打的话也许还能上紫吧，不知道呢. 还是要加油呀，至少跟上大家的步伐吧. </p><p><img src="https://s2.ax1x.com/2019/02/10/kU3wvj.png" alt=""></p><p>正月初六的 Div.  2 场打到自闭. 题目都不难，但是无端挂了一道，卡了一道，没时间放了一道，最后只完成了3题. 哎，论手速和心态的重要性. 临场发挥的作用甚比于个人水平. </p><p><img src="https://s2.ax1x.com/2019/02/11/ka8mH1.png" alt=""></p><p>事后又发现自己不会写线段树区间乘法？印象中明明写过的呀，都忘了吗？于是鸽了F. </p><p><img src="https://s2.ax1x.com/2019/02/11/kavn1J.png" alt=""></p><p>这天突然记起之前在cf上看到过一个vp hunter，就是那种可以给一组未参加过的比赛列表的小工具. 上谷哥搜了搜，就发现了这么一个东西：</p><p>Discord上有一个非常神奇的cf讨论组<a href="https://discordapp.com/channels/326795829664808960" target="_blank" rel="noopener">CP Community</a>，组内有个非常神奇的<a href="https://discordapp.com/channels/326795829664808960/339268856671502346" target="_blank" rel="noopener">bot</a>，这bot简直就是个神器. 有多神奇呢？你可以让这个bot提供一组可参加的vp比赛. . . <del>还可以让他和你尬聊</del></p><p>这个神奇的玩意儿是在cf某人的<a href="https://codeforces.com/blog/entry/52778" target="_blank" rel="noopener">blog</a>里发现的，可以说是业界良心了. </p><p>我马上就让他给我整了一组：</p><p><img src="https://s2.ax1x.com/2019/02/16/ksZcAx.png" alt=""></p><p>简直良心有木有！</p><p>妈妈再也不用担心我找不到vp场啦！</p><p><del>欸话说vp不就是在contest列表上翻一翻的事儿吗</del></p><p>然而尬聊功能好像下线了. . .</p><p>总之以后可以用这个bot找vp打啦！</p><p><del>总觉得你是在拿一个很trival的东西在水博客</del></p><p>当然，掌握科学上网的姿势是必要的！</p><p><del>肉身翻墙的请忽略233</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OI Life》开坑啦！每周六晚更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="OI Life" scheme="https://yclrz.github.io/tags/OI-Life/"/>
    
  </entry>
  
  <entry>
    <title>CCF WC2019 酱油记</title>
    <link href="https://yclrz.github.io/2019/01/30/CCF-WC2019-%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    <id>https://yclrz.github.io/2019/01/30/CCF-WC2019-酱油记/</id>
    <published>2019-01-30T14:39:48.000Z</published>
    <updated>2019-02-27T11:59:13.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上六点四十五起床去赶火车，坐了一上午+一中午的高铁终于到广州南站了，而且因为没准备车上的午餐饿的两眼发绿，一下车就吃了个肯德基。<a id="more"></a> 然后在大巴上颠簸了一个小时到了广州二中。路上还吃了把鸡。来宿舍后和其他湖北OIer面基，发现大家长得都很帅都很成熟，除了xqy还是个孩子的模样。其他人都是第一次见面，还记不住长相，同寝室有一个华一的，也记不住长相。晚上在学校食堂吃，这里的炸鱼块真好吃，看来这一个星期的伙食是不用担心了。八点半去报告厅看开幕式讲座，今年WC要考题答了，然而我还没见过题答，怕是要gg了（就算是传统题也会gg）。有趣的是开幕式有一个节目是阿卡贝拉合唱，然后当即有人发现了玄机：阿卡贝拉——AK不了！怕是真凉凉了（反正我是要爆零的QAQ）。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>今天是听课日，早上记错了时间去完了十分钟。坐在最后面听🌲🌲🌲讲评测系统，然后看他极力推荐评测鸭，发现这真是个厉害的东西，如果CCF也能用这样的评测系统就好了。中间还给听课的人发了一个小黄鸭（当然数量有限我又坐在最后面所以什么也没有），说是可以debug的时候用，还可以带入考场放松心情（其实我们机房也有一个学长留下来的魔方啦，一样的）。中午排了好长的队吃饭，不过等的时间并不长，被强行安排了好多基围虾，额。中午占好下午的座位后在学校里逛了会儿（实际上是找不到回寝室的路了233），在宿舍玩了玩边缘世界，并没有什么很大的进展。下午去听姚班大佬讲量子计算，因为自己实在是太菜加上教师太闷导致精神昏昏沉沉的，不小心趴了一会儿一睁眼就不知道在讲什么了，还好很快就到了课件休息的时候，和学弟跑回寝室了。晚上去体育馆试机，键盘手感好评，不过显示器一会儿就罢工了，不得不换了一台。用手机翻了翻ouuan的博客，看了他写的UER#3T1题解，%得五体投地。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>早上听了具体数学选讲和什么字符串算法，因为内容过（wo）于（tai）硬（cai）核（le）所以打了一上午瞌睡，而且还有点感冒。。。下午听IOI+ACM试题选讲，毫无悬念的又打了一下午瞌睡。。。晚上去听队爷讲课，发现除了LCA大爷讲了自己发明的黑科技，另外的都是搬运了很神奇的论文来讲，毫无悬念我一个都没懂。晚上的CF咕了，怕第二天上午听课吃到，虽然去了也是懵逼的。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>继续懵逼。。。晚上近距离接触了松爷，学弟还和松爷说话了orzorzorz</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>继续懵逼。。。</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>继续懵逼。。。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>考试day，早就做好爆零的准备了qwq（还有yyf继续吊打湖北的准备qwq）</p><p>考试前有小姐姐发面包和水好评（虽然面包没吃扔了）</p><p>因为事先被告知有三种不同题型，心里还是有点虚。</p><p>开T1，发现有几个点集训队分值为1，那么就把这几个点打了吧。打完已经过了两个小时了。代码写了3.8k，全是暴力，太惨了。</p><p>T2题面太长了，不想看，就爆零了qwq</p><p>T3很难搞啊，可能是我没看出有 $\le$ 和 $\ge$ 吧，一直纠结于相等的怎样处理，好在中途继承搞T1的战略把分值最小的点搞了，然后开始自闭，看了看交互库，发现相等会返回rand，然后花15min搞了个rand，虽然知道这样骗不到分，但是总不能闲着啊。最后15min想了想最小的数据点，好像有点搞头，然后考试结束辽。</p><p>考完后大家都很懵逼的样子（除我皆fAKe），中午打了几盘斗地主，一手好牌打得稀烂，去看成绩，发现高二我最低？哭辽qwq好像除我皆有牌的样子qwq果不其然yyf又吊打我们了qwq好像ag稳了的样子？去听了听题解，T1神奇的树计数+多项式？还以为prufer序列是不会考的，结果今年考出来了，多项式只会加减乘，呵呵。T2是什么毒瘤<del>乱</del> 搞法？没看题很懵逼。T3大力分析一波，各种大于等于，然后得到很神奇的做法？菜鸡表示只会手玩什么都不会qwq貌似打铁了qwq</p><p>晚上临时组织汇演，效率非常高，而且节目效果非常棒，我们都在不停的鼓掌或是大笑。不过后来出了车祸，因为组织者没有审查节目，导致有两个非常不合适的节目上台了，观众都挺尴尬的，最后还演化成动手事故了，收尾不太好，大家都很尴尬。</p><h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>早上被强行叫醒乘车去科技馆，路上晕车好难受。太阳好大好大，我还穿着羽绒服qwq等了半天终于进馆了，和学弟绕着馆玩，体验了一把翻车，人生第一次头朝下，感觉很好。因为早上没吃饭，中午饿的要死了，但就是不开饭。最后分到了一份盒饭，一点青菜加瘦肉，不过味道还行。吃完饭等了一个多小时刷知乎刷到自闭终于可以回去了，不知道为什么还要安排饭后有一个小时游览时间，本来一个小时的吃饭时间已经很多了，真的很无聊，差评。回寝室睡了会儿去看闭幕式，为什么要把灯打到观众席啊？本来想看看小姐姐跳舞的结果只能低头刷知乎了qwq中间穿插各种领导讲话，dzd也来了，开始讲话时挺有趣的，破冰效果很好，然后讲了讲传闻的OI成野鸡竞赛面临取缔的问题，告诉我们继续搞，CCF会去处理，算是对家长们的一个交代吧，毕竟从今天上午开始家长群就炸了（反正我很菜的我最多只能上hust的qwq）。</p><p>吃完饭和edt道了别，他们凌晨两点的火车还是快速的😂他们还打算先去看个电影再去车站，太厉害了。晚上继续颓啊颓，补完了酱游记。</p><p>WC唯一的收获就是一个铁牌和🌲🌲🌲的小黄鸭。顺便还搞丢了水壶。</p><p>恭喜湖北喜提三枚Ag，去年还有Au的，今年竟然还开倒车了。（<del>因为我拖后腿了</del>）</p><h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>回到湖北后才发现现在还是冬天😂因为广州一直都很热，丝毫感觉不到冬天的气息。</p><p>我还是喜欢湖北的气候，好歹四季分明吧，广州待着不习惯。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Day-0&quot;&gt;&lt;a href=&quot;#Day-0&quot; class=&quot;headerlink&quot; title=&quot;Day 0&quot;&gt;&lt;/a&gt;Day 0&lt;/h2&gt;&lt;p&gt;早上六点四十五起床去赶火车，坐了一上午+一中午的高铁终于到广州南站了，而且因为没准备车上的午餐饿的两眼发绿，一下车就吃了个肯德基。
    
    </summary>
    
    
      <category term="酱油记" scheme="https://yclrz.github.io/tags/%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2018酱油记</title>
    <link href="https://yclrz.github.io/2018/11/11/NOIP2018%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    <id>https://yclrz.github.io/2018/11/11/NOIP2018酱油记/</id>
    <published>2018-11-11T05:18:13.000Z</published>
    <updated>2019-02-27T11:59:18.870Z</updated>
    
    <content type="html"><![CDATA[<p>第一次写酱油记好激动哦～</p><a id="more"></a><h2 id="Day-365"><a href="#Day-365" class="headerlink" title="Day -365"></a>Day -365</h2><p>一年前的 NOIP2017 我爆零了QWQ</p><p>但是人家只会 DFS，能指望个啥嘛～</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day -10"></a>Day -10</h2><p>今天打 slay.one 的时候偶遇 WGSZ 的 Edgration 大佬，然后切磋了几把技术，加了 QQ</p><p>话说 Edgration 在今年九月份来过我的 QQ 空间，可能是因为我们都在 NOI2018 HB 交流群吧 233</p><p>（不过我们都是抱着看神仙的态度去的）</p><p>发现 WGSZ 的校内赛好 N13 的样子啊～（此处可能涉及人家的秘诀所以划掉）</p><p>然后看 Edgration CF 实力上分涨到 Candidate Master 心里好嫉妒羡慕哦～</p><p>（呜呜呜如果当初周末多打几场我也可以的 QWQ）</p><p>然后又认识发现了 VixBob 大佬</p><p>嗯嗯总之都是大佬就对了 233</p><p>听说 edt 大佬什么都会哦～可以吊打学长的哦～</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>今天去面基试机，终于见识了 edt 大佬和 bob 大佬本尊！</p><p>长得超帅的！</p><p>edt 好羞怯哦～打招呼时好腼腆的样子（嗯可能是本人太菜只配得上大佬一个微笑吧 233）</p><p>发现省选时和特派员哥哥大谈网络流的就是 bob 大佬诶！瞬间跪了！</p><p>当然除了 WGSZ 的大佬还见到了很多其它学校的大佬诶</p><p>还看到 HSY 组团游街吓得蒟蒻立刻让道了 233</p><p>好希望大佬们在 NOIP 能吊打我诶（什么心理啊(￣▽￣)）</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>哇紧张的早饭都没怎么吃就去考场了</p><p>其实是怕吃多了胀气 233</p><p>就准备了三颗费列罗撑一上午了</p><p>按照程序抽签抽到了 5 排 7 号</p><p>嗯没错就是那种人去世后的吊唁活动</p><p>怕是要凉凉的节奏哦</p><p>自己给自己上坟还行 233</p><p>但是即使这样也要把场面搞壮烈一点才行啊 QWQ</p><p>抱着就义的心态打开了题面。。。</p><p>发现第一题不送分诶！</p><p>差点以为自己要爆炸啦！</p><p>然后撑着脑袋想了一会儿，找个入手点，嗯，树状数组就决定是你了！</p><p>大样例过的飞快，走起～</p><p>不虚不虚，看 T2</p><p>哇塞啥玩意儿？？？高斯消元？线性空间？</p><p>完了完了我数学菜死了我要爆零了QWQ</p><p>然后陷入了无尽的深渊中无法自拔。。。</p><p>大概搞了一个半小时终于艹过去了。。。NM 竟然是完全背包！</p><p>不虚不虚！开 T3！</p><p>NM 树上贪心 + 二分！嗯大概就是这个思路了！</p><p>然后接下来的 45+ min 撑着脑袋想怎样贪心。。。</p><p>期间发现前排 WGSZ 大佬好像已经开始切了。。。不慌不慌。。。我菜。。。慢慢来。。。</p><p>然后大佬敲完了我还在想贪心怎么艹。。。</p><p>中途还上了一次厕所（不要指望我像大佬们那样上厕所是为了找灵感，我只是突然有生理需求而已 233）</p><p>回来后又想了想，开始敲代码！</p><p>QWQ 终于可以开始敲代码了。。。当时感觉大佬们都敲完了整个机房就只有我在小声地敲 QWQ 好丢脸啊</p><p>于是接下来的时间都在敲代码了。。。</p><p>当然代码不是一次敲完的。。。有好多坑要填的。。。</p><p>监考老师提前一刻钟报时时我还在敲 QWQ 要爆炸的节奏哦</p><p>感觉自己手速已经达到平生最高了 233</p><p>火速敲完 debug 过样例发现已经 11:50 了！</p><p>我艹当时差点要心梗了！感觉心脏有点痛了都！NM 真刺激啊！比蹦极什么的刺激多了！</p><p>眼泪都要飙出来了，欣喜之情无法言表。。。</p><p>冷静了 5 分钟，然后按照考场须知整理好文件，再三检查</p><p>可能真的是gang的太猛了，水都咽不下去了，冷静了好半天</p><p>真 TM 刺激！</p><p>（因为样例 AK 被同学 % 了好几次 233）</p><p>然后头疼了一下午 QWQ 怕是脑血管爆了哦 QWQ</p><p>回家睡了一下午才好一点，而且因为被子太厚差点以为自己发烧了 233</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>今天紧张度少了很多诶 233 脸皮太厚了</p><p>因为 day1 过于简单导致对 day2 的难度更虚了 233</p><p>抱着拿到 T1 100 分就滚粗的心态开了题</p><p>首先浏览了一番题目，心里有了一点 B 数</p><p>T1 尽然花了一个小时。。。题目读了好几遍 233</p><p>然后开 T2。。。</p><p>不说了都是泪。。。</p><p>一道 T2 送退役。。。</p><p>NM 什么鬼？我怕不是穿越了。。。这 NM 是省选把。。。</p><p>先是花半个小时打状压 + 矩阵快速幂，过不了样例，定神一想发现有鬼。。。</p><p>NM 好像不是这么搞的哦。。。凉了凉了。。。</p><p>然后一直在纸上画图猜规律，无果。。。</p><p>而且因为体力问题到 10:30 差不多就没脑力了 QWQ</p><p>吃了个费列罗也没用。。。</p><p>QWQ 心态崩了 QWQ</p><p>毫无向下思考的办法。。。真•蒟蒻的绝望。。。</p><p>到 11:50 左右终于放弃了。。。转头去敲 T3 暴力。。。没敲完。。。也弃了。。。</p><p>况且 T3 正解更没有头绪 QWQ</p><p>怕不是真的拿到 100 分就退役吧 QWQ 我还想和小伙伴在机房颓 steam 啊。。。</p><p>然后像僵尸一样出考场，看到老爸站在门口差点泪崩。。。太丢人了。。。没脸啊。。。</p><p>原来停了半年课还是只会打暴力啊 QWQ 果然还是太菜了</p><p>出考场大家好像都很沮丧的样子。。。</p><p>哎。。。</p><p>然后下午去看电影，clt 大佬一边看一边问其他人的情况</p><p>edt 大佬好像在 fAKe。。。cxy 大佬 / KS 大佬 暴力稳的很。。。</p><p>大概最多就打个暴力 200- 吧。。。500+ 没指望的。。。</p><p>嗯不知道 HSY 的大佬们怎么样了。。。他们真的好自闭啊。。。到现在一点消息都没有。。。</p><p>也许 HB 全村的希望真的就在 HSY 了 233</p><p>明年包揽省队集体出游也不是不可能的 233</p><p>反正广州那地方夏天热得要死，还有蟑螂蚊子啥的，谁爱去谁去，哼！</p><p>不过我省一大概稳了，可以花 2w 去打铁了 233</p><p>今年 NOIP 区分度真的低啊，没有什么能做的题。。。</p><p>（嗯当然是在不知道 HSY 的实力的情况下的，毕竟人家说不定会集体吊打我们这些散兵的）</p><p>现在就等初评了。。。能混一天是一天吧 233</p><h2 id="Day-2-5"><a href="#Day-2-5" class="headerlink" title="Day 2.5"></a>Day 2.5</h2><p>晚上十点源代码就发下来了，day1 T3 T掉三个点只有 85 分（不过学长安慰我说 CCF 的新 CPU 跑的飞快 233）</p><p>day2 代码出锅，解压出来全是乱码（这是在给我攒 rp 吗？）</p><p>所以期望得分 300？</p><p>一天 AK 一天爆零。。。不知道怎么形容了。。。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>今天一早机房就开始滚榜了</p><p>那些打 while(true) 的是什么心态啊？</p><p>昨天 edt 大佬狂fAKe，今天洛谷测出 359 pt。。。</p><p>cxy 大佬测出 415 pt，rk1 稳了！</p><p>徐教练联系特派员申诉去了，希望挽回一条命吧 233</p><p>机房 hxy 同志因为多打了一个 ‘w’ 痛失 100 pt，一个符号送退役 233</p><p>（握爪握爪）</p><h2 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day 3.1"></a>Day 3.1</h2><p>HSY 高一拿到了 300 pt，真的好强啊！</p><p>高二的估计要吊打我们了 233</p><h2 id="Day-3-2"><a href="#Day-3-2" class="headerlink" title="Day 3.2"></a>Day 3.2</h2><p>早上评测结束了，HSY 高二某大佬暴力打到了 480 pt。稳！</p><p>今年 HSY 怕不是要甩第二名 60 pt 哦！</p><h2 id="Day-3-3"><a href="#Day-3-3" class="headerlink" title="Day 3.3"></a>Day 3.3</h2><p>下午评测时有个外校高一大佬 AC 了 Day2T2。。。</p><p>%%%%%%</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>今天早上机房气氛很颓废 QWQ</p><p>我们高二集体被外校 + HSY 的高一大佬送退役了 233</p><p>看来我校未来的希望就在隔壁 xht 大佬身上了 233</p><p>还有更可怕的事。。。</p><p>高一 5 个学弟直接被教练强势劝退了。。。</p><p>没办法的事。。。</p><p>他们肯定拼不过同届的。。。</p><p>所以 xht 成为最后的希望了。。。</p><p>然后我校 OI 怕是要凉了。。。</p><p>想想真是可怜啊。。。</p><p>当年我校 OI 也是能在 NOI 上摘金夺银的。。。</p><p>现在一个 NOIP 就把大家打败了。。。</p><p>哎。。。</p><h2 id="Day-4-2"><a href="#Day-4-2" class="headerlink" title="Day 4.2"></a>Day 4.2</h2><p>下午颓的不要不要的</p><p>玩了一会儿泰拉瑞亚，感觉新手很容易玩腻的</p><p>然后下载了 dota2，实属没事找事干</p><p>目前没有跑过，听说会烧机？不管了，现在是冬天，万一烧了就拿室外冷一冷好了 233</p><p>另外感觉 day1T3 的 multiset 常数大？</p><p>好像全天下都在手写平衡树就我用 multiset 了。。。</p><p>希望良心 CCF 不要卡我 multiset 啊～</p><p>顺便不要吃掉我的 100 分啊～</p><p>如果 CCF 够良心我以后就给他氪金！</p><h2 id="Day-4-3"><a href="#Day-4-3" class="headerlink" title="Day 4.3"></a>Day 4.3</h2><p>dota2 竟然没有烧机，真是一件好事 233</p><p>开局中路贡献一血菜到不行 233</p><p>明天去学校继续提高水平吧 233</p><p>初评出来之前真的没有心情搞 OI/综合 了 qwq</p><p>另外看到 edt 说说上的退役感想，真的不希望那是真的</p><p>我还想跟着大佬 CF 上分呢！</p><p>他现在比我高 100 分，我还想追一追的</p><p>现在没有人陪我玩了 qwq（如果接下来我不退役的话）</p><p>（找不到 HSY 和外校大佬的账号诶）</p><p>呃。。。可能要拉着隔壁的学弟打了。。。让他吊打我是个好主意 233</p><h2 id="Day-10-1"><a href="#Day-10-1" class="headerlink" title="Day 10"></a>Day 10</h2><p>原本定于今天发布初评成绩，但是 CCF 咕咕咕了，要等到明天早上了。。。</p><p>下午和学弟们在机房开黑，嘿嘿嘿^_^</p><p>这几天一直很紧张地等成绩，几乎到了茶饭不思的地步了</p><p>我真可怜啊qwq</p><h2 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h2><p>复测结果下来了，88。。。</p><p>垃圾出题人连坑我两题哼</p><p>Day1T3也坑掉我 5 分，真是。。。无 fu 可说</p><h2 id="Day-13-2"><a href="#Day-13-2" class="headerlink" title="Day 13.2"></a>Day 13.2</h2><p>呵呵。。。所以最终得分 383？</p><p>当初指望着拿 400 整的，嗯嗯，结果谁料到出题人卡常？</p><p>话说学弟怎么就拿到 100 分了呢？洛谷上明明也TLE了，开 O2 就都过了，难道是复测时没有给我开 O2？好气啊 QAQ</p><p>（也有可能是学弟 rp 好 233）</p><p>然后学长评价是：</p><p><img src="https://img2018.cnblogs.com/blog/1296757/201811/1296757-20181122201620244-2139296301.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="Click and drag to move"></p><p><img src="https://img2018.cnblogs.com/blog/1296757/201811/1296757-20181122201821921-1577682091.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="Click and drag to move">我是不是太菜了 QAQ</p><p>之前学长让我打 CF、TC，还要做原题，预计结果是这样的：</p><p><img src="https://img2018.cnblogs.com/blog/1296757/201811/1296757-20181122202239006-1351435186.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="Click and drag to move"></p><p>所以我觉得是我没有打 TC 的原因</p><p>如果我打了 TC 就会有 400+ 了 QAQ</p><p>现在 HB 可以排 13，233</p><p>在 ZJ 可以直接退役了 QAQ</p><p>去 NOI 怕不是要被 ZJ 一堆大爷吊打哦 QAQ</p><p>蒟蒻瑟瑟发抖 QAQ</p><h2 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a>Day 17</h2><p>这几天比较闲散 233</p><p>趁着 steam 秋季折扣去买买买了一波 233</p><p><img src="https://img2018.cnblogs.com/blog/1296757/201811/1296757-20181127102704710-95823705.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="Click and drag to move"></p><p>然后开始肝群星了嘿嘿嘿</p><h2 id="Day-25"><a href="#Day-25" class="headerlink" title="Day 25"></a>Day 25</h2><p>下午 5 点成绩出来了，383 分。。。</p><p>看来今年卡常很吃亏了呢 QWQ</p><p>弱省蒟蒻就这样成功续命了呢 233</p><p>现在准备去 WC 膜大佬了 233</p><p>真的希望能坐上南航的大飞机啊 233</p><h3 id="Day-INF"><a href="#Day-INF" class="headerlink" title="Day INF"></a>Day INF</h3><p>哈哈，不能做飞机了，怕晚点，只能做高铁咯</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次写酱油记好激动哦～&lt;/p&gt;
    
    </summary>
    
    
      <category term="酱油记" scheme="https://yclrz.github.io/tags/%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
    
  </entry>
  
</feed>
